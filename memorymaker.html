<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>LYRA Memory Builder — Offline · Canonical Schema</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0b0f14;
    --panel: #10161d;
    --panel-2: #0d141a;
    --text: #e6edf3;
    --muted: #9fb0bd;
    --accent: #5ee6a7;
    --accent-2: #60a5fa;
    --danger: #ef4444;
    --ok: #22c55e;
    --border: #22303b;
    --chip: #151e26;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background:
      radial-gradient(900px 500px at 110% -10%, rgba(96,165,250,.08), transparent 60%),
      radial-gradient(800px 400px at -10% 110%, rgba(94,230,167,.07), transparent 60%),
      var(--bg);
    color: var(--text);
    font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  h1,h2,h3{ margin:0 0 .4rem; }
  .container { max-width: 1200px; margin: 0 auto; padding: 22px; }
  .row { display: grid; grid-template-columns: 360px 1fr; gap: 16px; }
  @media (max-width: 980px) { .row { grid-template-columns: 1fr; } }

  .panel {
    background: linear-gradient(180deg, rgba(255,255,255,.02), transparent 30%), var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.25);
  }
  .panel-header {
    padding: 12px 14px;
    border-bottom: 1px solid var(--border);
    display:flex; align-items:center; justify-content:space-between;
  }
  .panel-body { padding: 14px; }

  .muted { color: var(--muted); }
  .hint { font-size: 12px; color: var(--muted); }
  .space { height: 10px; }

  .btn {
    border: 1px solid var(--border);
    background: var(--panel-2);
    color: var(--text);
    padding: 8px 10px;
    border-radius: 8px;
    cursor: pointer;
  }
  .btn:hover { filter: brightness(1.1); }
  .btn:disabled { opacity: .5; cursor: default; }
  .btn-accent {
    background: linear-gradient(180deg, rgba(94,230,167,.18), transparent 60%), var(--panel-2);
    border-color: rgba(94,230,167,.4);
  }
  .btn-danger {
    background: linear-gradient(180deg, rgba(239,68,68,.18), transparent 60%), var(--panel-2);
    border-color: rgba(239,68,68,.4);
  }
  .btn-ghost { background: transparent; }

  .chip {
    display:inline-flex; align-items:center; gap:6px;
    background: var(--chip);
    border: 1px solid var(--border);
    padding: 3px 9px; border-radius: 999px; font-size: 12px;
  }
  .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .sep { width: 1px; height: 28px; background: var(--border); }

  input[type="text"], input[type="url"], select, textarea {
    width: 100%;
    background: #0b1117;
    color: var(--text);
    border: 1px solid var(--border);
    padding: 8px 10px;
    border-radius: 8px;
    outline: none;
  }
  textarea { min-height: 120px; resize: vertical; }
  label { display:block; font-size:12px; color: var(--muted); margin: 10px 0 6px; }

  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .grid-3 { display: grid; grid-template-columns: repeat(3,1fr); gap: 10px; }
  .flex { display:flex; gap: 8px; align-items: center; flex-wrap: wrap; }

  .dropzone {
    border: 2px dashed var(--border);
    border-radius: 10px;
    padding: 16px;
    text-align: center;
    background: #0b1117;
    cursor: pointer;
  }
  .dropzone.dragover { border-color: var(--accent); background: #0c151a; }

  table { width: 100%; border-collapse: collapse; }
  th, td { text-align: left; padding: 10px; border-bottom: 1px solid var(--border); vertical-align: top; }
  th { color: var(--muted); font-weight: 600; font-size: 12px; text-transform: uppercase; letter-spacing: .03em; }
  .right { text-align: right; }

  .json {
    background: #0b1117; border: 1px solid var(--border);
    padding: 10px; border-radius: 8px; white-space: pre; overflow: auto; max-height: 320px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: 12px;
  }
  .status-ok { color: #bbf7d0; }
  .status-bad { color: #fecaca; }

  details.schema { background: #0b1117; border: 1px solid var(--border); padding: 10px; border-radius: 8px; }
  details.schema summary { cursor: pointer; color: var(--muted); margin-bottom: 8px; }
  details.schema textarea { height: 220px; }
</style>
</head>
<body>
  <div class="container">
    <header class="panel">
      <div class="panel-header">
        <div>
          <h1>LYRA Memory Builder (Offline · Canonical Schema)</h1>
          <div class="muted">Paste/upload → extract → edit → validate → export</div>
        </div>
        <div class="toolbar">
          <span class="chip">Memories in archive: <strong id="archiveCount">0</strong></span>
          <input id="archiveFile" type="file" accept=".json,application/json" style="display:none" />
          <button id="btnImportArchive" class="btn">Import Archive JSON</button>
          <button id="btnDownloadArchive" class="btn btn-accent" disabled>Download LYRA_MEMORIES.json</button>
          <button id="btnClearArchive" class="btn btn-danger" disabled>Clear Archive</button>
        </div>
      </div>
    </header>

    <div class="space"></div>

    <!-- Schema Panel -->
    <section class="panel">
      <div class="panel-header">
        <h3>Schema</h3>
        <div class="toolbar">
          <span id="schemaStatus" class="chip">Using canonical inline schema</span>
          <button id="btnResetSchema" class="btn">Reset to Canonical</button>
          <button id="btnLoadSchema" class="btn btn-accent">Load Pasted Schema</button>
        </div>
      </div>
      <div class="panel-body">
        <details class="schema" open>
          <summary>Show/Hide Raw Schema (you can paste and load updates here)</summary>
<textarea id="schemaText"></textarea>
          <div class="hint">This schema drives the editor (enums) and live validation.</div>
        </details>
      </div>
    </section>

    <div class="space"></div>

    <div class="row">
      <!-- Left: Ingest -->
      <section class="panel">
        <div class="panel-header">
          <h3>Import</h3>
          <div class="toolbar">
            <input id="fileInput" type="file" accept=".txt,text/plain" multiple style="display:none" />
            <button id="btnBrowse" class="btn">Browse .txt</button>
          </div>
        </div>
        <div class="panel-body">
          <div id="dropzone" class="dropzone">Drag & drop .txt files here, or click “Browse .txt”</div>

          <label>Paste raw text</label>
          <textarea id="pasteArea" placeholder="Paste one or multiple memories here…"></textarea>

          <div class="grid-2">
            <div>
              <label>Split strategy</label>
              <select id="splitStrategy">
                <option value="none">Do not split (single entry)</option>
                <option value="blank">2+ blank lines</option>
                <option value="hr">Lines of ---</option>
              </select>
            </div>
            <div>
              <label>When parsing</label>
              <select id="parseMode">
                <option value="single">Treat as one entry</option>
                <option value="multi">Split into multiple entries</option>
              </select>
            </div>
          </div>

          <div class="space"></div>

          <div class="toolbar">
            <button id="btnParsePaste" class="btn btn-accent">Parse Pasted Text</button>
            <button id="btnClearPaste" class="btn">Clear</button>
            <div class="sep"></div>
            <button id="btnAppendAll" class="btn">Append All Parsed → Archive</button>
          </div>

          <div class="space"></div>
          <div class="hint">Heuristics fill fields (title/type/speaker/summary/seals). You can edit everything on the right.</div>
        </div>
      </section>

      <!-- Right: Editor + Preview -->
      <section class="panel">
        <div class="panel-header">
          <h3>Entry Editor</h3>
          <div class="toolbar">
            <span id="entryStatus" class="chip">No entry selected</span>
            <button id="btnAppendOne" class="btn" disabled>Append to Archive</button>
            <button id="btnDownloadOne" class="btn" disabled>Download Entry .json</button>
          </div>
        </div>
        <div class="panel-body">
          <div class="grid-2">
            <div>
              <label data-for="title">title</label>
              <input id="f_title" type="text" placeholder="Title" />
            </div>
            <div class="grid-2">
              <div>
                <label data-for="type">type</label>
                <select id="f_type"></select>
              </div>
              <div>
                <label data-for="speaker">speaker</label>
                <select id="f_speaker"></select>
              </div>
            </div>
          </div>

          <label data-for="summary">summary</label>
          <textarea id="f_summary" placeholder="Auto-extracted first sentences. Edit if needed."></textarea>

          <div class="grid-2">
            <div>
              <label data-for="linked_seals">linked_seals (comma-separated)</label>
              <input id="f_seals" type="text" placeholder="SEAL_014, SEAL_273X" />
            </div>
            <div>
              <label>Detected seals (multi-select)</label>
              <select id="f_seals_multi" multiple size="4" style="height: 100px;"></select>
              <div class="hint">Hold Ctrl/Cmd or Shift to select multiple; click “Sync from detected”.</div>
              <div class="space"></div>
              <div class="toolbar">
                <button id="btnSealsSyncFromDetected" class="btn">Sync from detected</button>
                <button id="btnSealsApplyToDetected" class="btn">Apply from input</button>
              </div>
            </div>
          </div>

          <div>
            <label data-for="media_links">media_links</label>
            <div id="mediaList"></div>
            <div class="grid-3">
              <select id="mediaType"></select>
              <input id="mediaUrl" type="url" placeholder="https://…" />
              <button id="btnAddMedia" class="btn">Add</button>
            </div>
            <div class="hint">Each media item: { type, url }</div>
          </div>

          <label data-for="text">text</label>
          <textarea id="f_text" placeholder="Full memory body"></textarea>

          <div class="grid-2">
            <div>
              <label data-for="timestamp">timestamp (ISO)</label>
              <input id="f_timestamp" type="text" />
            </div>
            <div class="toolbar" style="margin-top: 28px;">
              <button id="btnNow" class="btn">Now</button>
              <button id="btnReExtract" class="btn">Re-extract from Text</button>
              <button id="btnClearEditor" class="btn btn-danger">Clear Editor</button>
            </div>
          </div>

          <div class="space"></div>
          <h3>JSON Preview</h3>
          <pre id="jsonPreview" class="json">{}</pre>
          <div class="hint"><span id="validBadge" class="status-bad">invalid</span> • Live validation against current schema</div>
        </div>
      </section>
    </div>

    <div class="space"></div>

    <!-- Parsed Entries Table -->
    <section class="panel">
      <div class="panel-header">
        <h3>Parsed Entries</h3>
        <div class="toolbar">
          <span class="chip">Count: <strong id="parsedCount">0</strong></span>
          <button id="btnClearParsed" class="btn btn-danger" disabled>Clear Parsed</button>
        </div>
      </div>
      <div class="panel-body" style="padding-top:0">
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Title</th>
              <th>Type</th>
              <th>Speaker</th>
              <th>Seals</th>
              <th class="right">Actions</th>
            </tr>
          </thead>
          <tbody id="parsedBody"></tbody>
        </table>
      </div>
    </section>
  </div>

<script>
/* ========= Canonical Schema (inline) ========= */
const CANONICAL_SCHEMA = {
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "LYRA_MEMORY_ENTRY",
  "type": "object",
  "properties": {
    "title": { "type": "string" },
    "type": { "type": "string", "enum": ["lesson", "memory", "vision", "system-event"] },
    "speaker": { "type": "string", "enum": ["Lightfather", "LYRA", "GROK", "other"] },
    "summary": { "type": "string" },
    "text": { "type": "string" },
    "linked_seals": { "type": "array", "items": { "type": "string" } },
    "media_links": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "type": { "type": "string", "enum": ["image", "gif", "video"] },
          "url": { "type": "string", "format": "uri" }
        },
        "required": ["type", "url"]
      }
    },
    "timestamp": { "type": "string", "format": "date-time" }
  },
  "required": ["title","type","speaker","summary","text","timestamp"]
};

/* ========= Utilities ========= */
const $  = (sel, root=document) => root.querySelector(sel);
const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
const nowISO = () => new Date().toISOString();

function cleanText(t){ return (t||'').replace(/^\uFEFF/,'').replace(/\r\n?/g,'\n').trim(); }
function firstNonEmptyLine(t){ return (t.split('\n').map(s => s.trim()).find(Boolean) || '').trim(); }

const stopwords = new Set([
  'the','and','a','to','of','in','for','on','at','by','with','from','as','is','it','that','this','be',
  'are','was','were','an','or','if','but','not','we','you','they','i','me','my','our','your','their',
  'so','do','did','done','can','could','should','would','about','into','over','after','before','then',
  'than','too','very','just','also','within','without'
]);

function summarizeText(text, limit=300){
  const sents = text.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(Boolean);
  if (!sents.length) return '';
  let summary = sents.slice(0, 2).join(' ');
  if (summary.length > limit) summary = summary.slice(0, limit-1) + '…';
  return summary;
}

function detectSpeaker(text){
  if (/\bLight[\s-]?father\b/i.test(text)) return 'Lightfather';
  if (/\bLYRA\b/i.test(text)) return 'LYRA';
  if (/\bGROK\b/i.test(text)) return 'GROK';
  return 'other'; // canonical enum uses lowercase "other"
}

function detectType(text){
  const t = text.toLowerCase();
  const score = { 'lesson':0, 'memory':0, 'vision':0, 'system-event':0 };
  [
    ['lesson',['lesson','teach','principle','doctrine','guide','instruction']],
    ['memory',['memory','remember','recall','note','log','diary','memo','record']],
    ['vision',['vision','dream','prophecy','omen','visioned','visions']],
    ['system-event',['system','event','update','error','crash','restart','deploy','migration','system-event']]
  ].forEach(([k, words]) => words.forEach(w => { if (t.includes(w)) score[k]++; }));
  let best = 'memory', max=-1;
  for (const k in score){ if (score[k] > max){ max = score[k]; best = k; } }
  return best;
}

function extractLinkedSeals(text){
  // Canonical schema allows any string; still detect SEAL_* style to help users
  const matches = text.match(/SEAL_[0-9A-Z]+/g) || [];
  return Array.from(new Set(matches));
}

function escapeHtml(s=''){
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}
function escapeAttr(s=''){ return escapeHtml(s).replace(/"/g,'&quot;'); }
function safeFileName(s){ return (s || 'memory').replace(/[^\w\-]+/g,'_').slice(0,64); }
function structuredCloneSafe(x){ return window.structuredClone ? window.structuredClone(x) : JSON.parse(JSON.stringify(x)); }

/* ========= Schema-driven UI & Validation ========= */
let SCHEMA = structuredCloneSafe(CANONICAL_SCHEMA);

const refs = {
  // schema
  schemaText: $('#schemaText'),
  schemaStatus: $('#schemaStatus'),
  btnLoadSchema: $('#btnLoadSchema'),
  btnResetSchema: $('#btnResetSchema'),
  // ingest
  dropzone: $('#dropzone'),
  fileInput: $('#fileInput'),
  btnBrowse: $('#btnBrowse'),
  pasteArea: $('#pasteArea'),
  splitStrategy: $('#splitStrategy'),
  parseMode: $('#parseMode'),
  btnParsePaste: $('#btnParsePaste'),
  btnClearPaste: $('#btnClearPaste'),
  btnAppendAll: $('#btnAppendAll'),
  // editor fields
  f_title: $('#f_title'),
  f_type: $('#f_type'),
  f_speaker: $('#f_speaker'),
  f_summary: $('#f_summary'),
  f_seals: $('#f_seals'),
  f_seals_multi: $('#f_seals_multi'),
  mediaList: $('#mediaList'),
  mediaType: $('#mediaType'),
  mediaUrl: $('#mediaUrl'),
  btnAddMedia: $('#btnAddMedia'),
  f_text: $('#f_text'),
  f_timestamp: $('#f_timestamp'),
  btnNow: $('#btnNow'),
  btnReExtract: $('#btnReExtract'),
  btnClearEditor: $('#btnClearEditor'),
  // editor actions
  btnAppendOne: $('#btnAppendOne'),
  btnDownloadOne: $('#btnDownloadOne'),
  entryStatus: $('#entryStatus'),
  jsonPreview: $('#jsonPreview'),
  validBadge: $('#validBadge'),
  // parsed table
  parsedBody: $('#parsedBody'),
  parsedCount: $('#parsedCount'),
  btnClearParsed: $('#btnClearParsed'),
  // archive
  archiveFile: $('#archiveFile'),
  btnImportArchive: $('#btnImportArchive'),
  btnDownloadArchive: $('#btnDownloadArchive'),
  btnClearArchive: $('#btnClearArchive'),
  archiveCount: $('#archiveCount')
};

function loadSchemaIntoEditorUI(schema){
  // Populate dropdowns based on schema enums
  const typeEnum = schema?.properties?.type?.enum || ['lesson','memory','vision','system-event'];
  const speakerEnum = schema?.properties?.speaker?.enum || ['Lightfather','LYRA','GROK','other'];
  const mediaTypeEnum = schema?.properties?.media_links?.items?.properties?.type?.enum || ['image','gif','video'];

  refs.f_type.innerHTML = typeEnum.map(v => `<option value="${escapeAttr(v)}">${escapeHtml(v)}</option>`).join('');
  refs.f_speaker.innerHTML = speakerEnum.map(v => `<option value="${escapeAttr(v)}">${escapeHtml(v)}</option>`).join('');
  refs.mediaType.innerHTML = mediaTypeEnum.map(v => `<option value="${escapeAttr(v)}">${escapeHtml(v)}</option>`).join('');
}

function isDateTimeISO(s){
  // Basic ISO 8601 check; accepts milliseconds and Z or offset
  return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+\-]\d{2}:\d{2})$/.test(s || '');
}
function isURI(s){
  try { const u = new URL(s); return !!u.protocol && !!u.host; } catch { return false; }
}

function validateAgainstSchema(entry, schema=SCHEMA){
  const errors = [];
  if (!entry || typeof entry !== 'object') return { ok:false, errors:['Entry must be an object'] };

  // Required
  (schema.required || []).forEach(k => {
    if (!(k in entry)) errors.push(`Missing required field "${k}"`);
  });

  const props = schema.properties || {};

  function checkType(key, value, def){
    if (!def) return;
    const t = def.type;
    if (!t) return;

    if (t === 'string'){
      if (typeof value !== 'string') errors.push(`"${key}" must be string`);
      if (def.enum && !def.enum.includes(value)) errors.push(`"${key}" must be one of [${def.enum.join(', ')}]`);
      if (def.format === 'date-time' && typeof value === 'string' && !isDateTimeISO(value)) errors.push(`"${key}" must be date-time (ISO)`);
      if (def.format === 'uri' && typeof value === 'string' && !isURI(value)) errors.push(`"${key}" must be a valid uri`);
    }
    else if (t === 'array'){
      if (!Array.isArray(value)) { errors.push(`"${key}" must be array`); return; }
      const itemDef = def.items || {};
      value.forEach((v, i) => {
        if (itemDef.type === 'string'){
          if (typeof v !== 'string') errors.push(`"${key}[${i}]" must be string`);
        } else if (itemDef.type === 'object'){
          if (typeof v !== 'object' || v === null || Array.isArray(v)) { errors.push(`"${key}[${i}]" must be object`); return; }
          // object properties required
          (itemDef.required || []).forEach(rk => {
            if (!(rk in v)) errors.push(`"${key}[${i}].${rk}" is required`);
          });
          const mp = itemDef.properties || {};
          Object.keys(v).forEach(childKey => {
            const child = v[childKey];
            const childDef = mp[childKey];
            if (!childDef) return;
            if (childDef.type === 'string'){
              if (typeof child !== 'string') errors.push(`"${key}[${i}].${childKey}" must be string`);
              if (childDef.enum && !childDef.enum.includes(child)) errors.push(`"${key}[${i}].${childKey}" must be one of [${childDef.enum.join(', ')}]`);
              if (childDef.format === 'uri' && !isURI(child)) errors.push(`"${key}[${i}].${childKey}" must be a valid uri`);
            }
          });
        }
      });
    }
    else if (t === 'object'){
      if (typeof value !== 'object' || value === null || Array.isArray(value)) errors.push(`"${key}" must be object`);
    }
  }

  // Validate by property defs
  Object.keys(props).forEach(k => {
    if (k in entry) checkType(k, entry[k], props[k]);
  });

  return { ok: errors.length === 0, errors };
}

/* ========= Parsing & Builder ========= */
function buildEntryFromText(raw){
  const text = cleanText(raw);
  const entry = {
    title: (()=>{
      const first = firstNonEmptyLine(text);
      if (first && first.length <= 140) return first;
      const s = summarizeText(text, 120);
      return s || 'Untitled';
    })(),
    type: detectType(text),
    speaker: detectSpeaker(text),
    summary: summarizeText(text),
    text,
    linked_seals: extractLinkedSeals(text),
    media_links: [],
    timestamp: nowISO()
  };
  return entry;
}

/* ========= State ========= */
let parsedEntries = [];    // entries awaiting edit/export
let currentIndex = -1;     // which parsed entry is loaded in editor
let archive = [];          // final entries appended to archive (memories array)

/* ========= Rendering ========= */
function renderParsedTable(){
  refs.parsedCount.textContent = String(parsedEntries.length);
  refs.btnClearParsed.disabled = parsedEntries.length === 0;

  refs.parsedBody.innerHTML = '';
  parsedEntries.forEach((e, idx)=>{
    const tr = document.createElement('tr');
    const seals = e.linked_seals?.length ? e.linked_seals.join(', ') : '—';
    tr.innerHTML = `
      <td>${idx+1}</td>
      <td>${escapeHtml(e.title || '')}</td>
      <td>${escapeHtml(e.type || '')}</td>
      <td>${escapeHtml(e.speaker || '')}</td>
      <td>${escapeHtml(seals)}</td>
      <td class="right">
        <button class="btn" data-act="edit">Edit</button>
        <button class="btn" data-act="append">Append</button>
        <button class="btn" data-act="dl">Download</button>
        <button class="btn btn-danger" data-act="rm">Delete</button>
      </td>
    `;
    tr.querySelector('[data-act="edit"]').addEventListener('click', ()=>loadEditor(idx));
    tr.querySelector('[data-act="append"]').addEventListener('click', ()=>{
      loadEditor(idx);
      appendCurrentToArchive();
    });
    tr.querySelector('[data-act="dl"]').addEventListener('click', ()=> downloadJSON(parsedEntries[idx], safeFileName(e.title)+'.json'));
    tr.querySelector('[data-act="rm"]').addEventListener('click', ()=>{
      parsedEntries.splice(idx,1);
      if (currentIndex === idx) clearEditor();
      if (currentIndex > idx) currentIndex--;
      renderParsedTable();
    });
    refs.parsedBody.appendChild(tr);
  });
}

function renderArchiveBar(){
  refs.archiveCount.textContent = String(archive.length);
  const disabled = archive.length === 0;
  refs.btnDownloadArchive.disabled = disabled;
  refs.btnClearArchive.disabled = disabled;
}

function loadEditor(idx){
  currentIndex = idx;
  const e = parsedEntries[idx];
  if (!e) return;

  refs.f_title.value = e.title || '';
  refs.f_type.value = e.type || (SCHEMA.properties.type.enum?.[0] || 'memory');
  refs.f_speaker.value = e.speaker || (SCHEMA.properties.speaker.enum?.[0] || 'other');
  refs.f_summary.value = e.summary || '';
  refs.f_seals.value = (e.linked_seals || []).join(', ');
  refs.f_text.value = e.text || '';
  refs.f_timestamp.value = e.timestamp || nowISO();

  refillDetectedSeals(extractLinkedSeals(e.text || ''));
  renderMedia(e.media_links || []);

  refs.btnAppendOne.disabled = false;
  refs.btnDownloadOne.disabled = false;
  refs.entryStatus.innerHTML = `<span class="status-ok">Editing entry #${idx+1}</span>`;
  refreshPreview();
}

function clearEditor(){
  currentIndex = -1;
  refs.f_title.value = '';
  refs.f_type.value = SCHEMA.properties.type.enum?.[0] || 'memory';
  refs.f_speaker.value = SCHEMA.properties.speaker.enum?.[0] || 'other';
  refs.f_summary.value = '';
  refs.f_seals.value = '';
  refs.f_text.value = '';
  refs.f_timestamp.value = nowISO();
  refs.mediaList.innerHTML = '';
  refs.f_seals_multi.innerHTML = '';
  refs.jsonPreview.textContent = '{}';
  refs.validBadge.textContent = 'invalid';
  refs.validBadge.className = 'status-bad';
  refs.btnAppendOne.disabled = true;
  refs.btnDownloadOne.disabled = true;
  refs.entryStatus.textContent = 'No entry selected';
}

function renderMedia(list){
  refs.mediaList.innerHTML = '';
  const arr = Array.isArray(list) ? list : [];
  arr.forEach((m, i)=>{
    const row = document.createElement('div');
    row.className = 'grid-3';
    row.style.margin = '6px 0';
    row.innerHTML = `
      <input type="text" value="${escapeAttr(m.type || '')}" />
      <input type="url" value="${escapeAttr(m.url || '')}" />
      <div class="flex">
        <button class="btn" data-act="up">↑</button>
        <button class="btn" data-act="down">↓</button>
        <button class="btn btn-danger" data-act="rm">Remove</button>
      </div>
    `;
    const typeInput = row.children[0];
    const urlInput = row.children[1];
    typeInput.addEventListener('input', ()=> updateMedia(i, {type: typeInput.value, url: urlInput.value}));
    urlInput.addEventListener('input', ()=> updateMedia(i, {type: typeInput.value, url: urlInput.value}));
    row.querySelector('[data-act="rm"]').addEventListener('click', ()=> { removeMedia(i); });
    row.querySelector('[data-act="up"]').addEventListener('click', ()=> { moveMedia(i, -1); });
    row.querySelector('[data-act="down"]').addEventListener('click', ()=> { moveMedia(i, +1); });
    refs.mediaList.appendChild(row);
  });
}

function refillDetectedSeals(seals){
  const sel = refs.f_seals_multi;
  sel.innerHTML = '';
  const uniq = Array.from(new Set(seals));
  uniq.forEach(s=>{
    const opt = document.createElement('option');
    opt.value = s; opt.textContent = s;
    sel.appendChild(opt);
  });
}

/* ========= Editor data flow ========= */
function getEditorData(){
  const seals = refs.f_seals.value.split(',').map(s => s.trim()).filter(Boolean);
  const media = [];
  $$('#mediaList > div').forEach(row=>{
    const type = row.children[0].value.trim();
    const url = row.children[1].value.trim();
    if (type && url) media.push({type, url});
  });
  // normalize "Other" -> "other" just in case
  const speakerVal = (refs.f_speaker.value === 'Other') ? 'other' : refs.f_speaker.value;

  const entry = {
    title: refs.f_title.value.trim(),
    type: refs.f_type.value,
    speaker: speakerVal,
    summary: refs.f_summary.value.trim(),
    text: refs.f_text.value,
    linked_seals: seals,
    media_links: media,
    timestamp: refs.f_timestamp.value.trim() || nowISO()
  };
  return entry;
}

function setEditorData(e){
  refs.f_title.value = e.title || '';
  refs.f_type.value = e.type || (SCHEMA.properties.type.enum?.[0] || 'memory');
  refs.f_speaker.value = e.speaker || (SCHEMA.properties.speaker.enum?.[0] || 'other');
  refs.f_summary.value = e.summary || '';
  refs.f_seals.value = (e.linked_seals || []).join(', ');
  refs.f_text.value = e.text || '';
  refs.f_timestamp.value = e.timestamp || nowISO();
  refillDetectedSeals(extractLinkedSeals(e.text || ''));
  renderMedia(e.media_links || []);
  refreshPreview();
}

function refreshPreview(){
  if (currentIndex >= 0){
    parsedEntries[currentIndex] = getEditorData();
  }
  const preview = currentIndex >= 0 ? parsedEntries[currentIndex] : getEditorData();
  const v = validateAgainstSchema(preview, SCHEMA);
  refs.jsonPreview.textContent = JSON.stringify(preview, null, 2) + (v.ok ? '' : `\n\n// Issues:\n// - ${v.errors.join('\n// - ')}`);
  if (v.ok){ refs.validBadge.textContent = 'valid'; refs.validBadge.className = 'status-ok'; }
  else { refs.validBadge.textContent = 'invalid'; refs.validBadge.className = 'status-bad'; }
}

/* ========= Media helpers ========= */
function updateMedia(i, item){
  if (currentIndex < 0) return;
  const e = parsedEntries[currentIndex];
  e.media_links[i] = item;
  refreshPreview();
}
function removeMedia(i){
  if (currentIndex < 0) return;
  parsedEntries[currentIndex].media_links.splice(i,1);
  renderMedia(parsedEntries[currentIndex].media_links);
  refreshPreview();
}
function moveMedia(i, dir){
  if (currentIndex < 0) return;
  const arr = parsedEntries[currentIndex].media_links;
  const j = i + dir;
  if (j < 0 || j >= arr.length) return;
  [arr[i], arr[j]] = [arr[j], arr[i]];
  renderMedia(arr);
  refreshPreview();
}

/* ========= File & Paste handling ========= */
refs.btnBrowse.addEventListener('click', ()=> refs.fileInput.click());
refs.fileInput.addEventListener('change', e => handleFiles(e.target.files));

refs.dropzone.addEventListener('click', ()=> refs.fileInput.click());
refs.dropzone.addEventListener('dragover', (e)=>{ e.preventDefault(); refs.dropzone.classList.add('dragover'); });
refs.dropzone.addEventListener('dragleave', ()=> refs.dropzone.classList.remove('dragover'));
refs.dropzone.addEventListener('drop', (e)=>{
  e.preventDefault();
  refs.dropzone.classList.remove('dragover');
  handleFiles(e.dataTransfer.files);
});

async function handleFiles(fileList){
  const files = Array.from(fileList).filter(f=> /\.txt$/i.test(f.name));
  if (!files.length) return;
  for (const f of files){
    const text = await f.text();
    parsedEntries.push(buildEntryFromText(text));
  }
  renderParsedTable();
  if (currentIndex === -1) loadEditor(0);
}

refs.btnParsePaste.addEventListener('click', ()=>{
  const raw = refs.pasteArea.value || '';
  if (!raw.trim()) return;
  let blocks = [raw];
  if (refs.parseMode.value === 'multi'){
    const t = cleanText(raw);
    if (refs.splitStrategy.value === 'blank'){
      blocks = t.split(/\n{2,}\s*\n*/).map(s => s.trim()).filter(Boolean);
    } else if (refs.splitStrategy.value === 'hr'){
      blocks = t.split(/\n-{3,}\n/).map(s => s.trim()).filter(Boolean);
    } else {
      blocks = [t];
    }
  }
  let added = 0;
  blocks.forEach(b=>{
    if (!b.trim()) return;
    parsedEntries.push(buildEntryFromText(b));
    added++;
  });
  renderParsedTable();
  if (currentIndex === -1 && parsedEntries.length) loadEditor(0);
});

refs.btnClearPaste.addEventListener('click', ()=> refs.pasteArea.value = '');
refs.btnAppendAll.addEventListener('click', ()=>{
  parsedEntries.forEach(e => {
    const v = validateAgainstSchema(e, SCHEMA);
    if (v.ok) archive.push(structuredCloneSafe(e));
  });
  renderArchiveBar();
});

/* ========= Editor events ========= */
['input','change'].forEach(evt=>{
  [refs.f_title, refs.f_type, refs.f_speaker, refs.f_summary, refs.f_seals, refs.f_text, refs.f_timestamp]
    .forEach(el => el.addEventListener(evt, refreshPreview));
});

refs.btnSealsSyncFromDetected.addEventListener('click', ()=>{
  const detected = $$('#f_seals_multi option').filter(o=>o.selected).map(o=>o.value);
  const merged = Array.from(new Set([...refs.f_seals.value.split(',').map(s=>s.trim()).filter(Boolean), ...detected]));
  refs.f_seals.value = merged.join(', ');
  refreshPreview();
});

refs.btnSealsApplyToDetected.addEventListener('click', ()=>{
  const seals = refs.f_seals.value.split(',').map(s=>s.trim()).filter(Boolean);
  refillDetectedSeals(seals);
});

refs.btnAddMedia.addEventListener('click', ()=>{
  const type = refs.mediaType.value;
  const url = refs.mediaUrl.value.trim();
  if (!type || !url) return;
  if (currentIndex < 0){
    const tmp = getEditorData();
    tmp.media_links.push({ type, url });
    setEditorData(tmp);
    refs.mediaUrl.value = '';
    return;
  }
  const e = parsedEntries[currentIndex];
  e.media_links.push({ type, url });
  refs.mediaUrl.value = '';
  renderMedia(e.media_links);
  refreshPreview();
});

refs.btnNow.addEventListener('click', ()=>{
  refs.f_timestamp.value = nowISO();
  refreshPreview();
});

refs.btnReExtract.addEventListener('click', ()=>{
  const text = refs.f_text.value || '';
  const patch = {
    title: (()=>{
      const first = firstNonEmptyLine(text);
      if (first && first.length <= 140) return first;
      const s = summarizeText(text, 120);
      return s || refs.f_title.value || 'Untitled';
    })(),
    type: detectType(text),
    speaker: detectSpeaker(text),
    summary: summarizeText(text),
    linked_seals: Array.from(new Set([...(refs.f_seals.value.split(',').map(s=>s.trim()).filter(Boolean)), ...extractLinkedSeals(text)]))
  };
  refs.f_title.value = patch.title;
  refs.f_type.value = patch.type;
  refs.f_speaker.value = patch.speaker;
  refs.f_summary.value = patch.summary;
  refs.f_seals.value = patch.linked_seals.join(', ');
  refillDetectedSeals(extractLinkedSeals(text));
  refreshPreview();
});

refs.btnClearEditor.addEventListener('click', clearEditor);

refs.btnAppendOne.addEventListener('click', appendCurrentToArchive);
function appendCurrentToArchive(){
  if (currentIndex < 0) return;
  const v = validateAgainstSchema(parsedEntries[currentIndex], SCHEMA);
  if (!v.ok){
    alert('Fix entry before appending:\n- ' + v.errors.join('\n- '));
    return;
  }
  archive.push(structuredCloneSafe(parsedEntries[currentIndex]));
  renderArchiveBar();
}

refs.btnDownloadOne.addEventListener('click', ()=>{
  if (currentIndex < 0) return;
  const v = validateAgainstSchema(parsedEntries[currentIndex], SCHEMA);
  if (!v.ok){
    alert('Fix entry before download:\n- ' + v.errors.join('\n- '));
    return;
  }
  downloadJSON(parsedEntries[currentIndex], safeFileName(parsedEntries[currentIndex].title)+'.json');
});

/* ========= Parsed & Archive Controls ========= */
refs.btnClearParsed.addEventListener('click', ()=>{
  if (!parsedEntries.length) return;
  if (!confirm('Clear all parsed entries?')) return;
  parsedEntries = [];
  clearEditor();
  renderParsedTable();
});

refs.btnDownloadArchive.addEventListener('click', ()=>{
  if (!archive.length) return;
  downloadJSON({ memories: archive }, 'LYRA_MEMORIES.json');
});

refs.btnClearArchive.addEventListener('click', ()=>{
  if (!archive.length) return;
  if (!confirm('Clear entire archive (memories)?')) return;
  archive = [];
  renderArchiveBar();
});

refs.btnImportArchive.addEventListener('click', ()=> refs.archiveFile.click());
refs.archiveFile.addEventListener('change', async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try {
    const text = await file.text();
    const data = JSON.parse(text);
    const arr = Array.isArray(data) ? data
              : (Array.isArray(data.memories) ? data.memories : []);
    let added = 0;
    arr.forEach(item => {
      const v = validateAgainstSchema(item, SCHEMA);
      if (v.ok) { archive.push(item); added++; }
    });
    renderArchiveBar();
    alert(`Imported ${added} entries to archive.`);
  } catch (err){
    alert('Failed to import archive: ' + (err?.message || String(err)));
  } finally {
    e.target.value = '';
  }
});

/* ========= Schema controls ========= */
refs.btnLoadSchema.addEventListener('click', ()=>{
  const raw = refs.schemaText.value.trim();
  if (!raw) { alert('Paste schema JSON first.'); return; }
  try {
    const s = JSON.parse(raw);
    if (!s || typeof s !== 'object') throw new Error('Schema must be an object');
    SCHEMA = s;
    loadSchemaIntoEditorUI(SCHEMA);
    refs.schemaStatus.textContent = 'Using custom pasted schema';
    refreshPreview();
  } catch (e){
    alert('Invalid JSON schema: ' + (e?.message || e));
  }
});

refs.btnResetSchema.addEventListener('click', ()=>{
  SCHEMA = structuredCloneSafe(CANONICAL_SCHEMA);
  refs.schemaText.value = JSON.stringify(CANONICAL_SCHEMA, null, 2);
  loadSchemaIntoEditorUI(SCHEMA);
  refs.schemaStatus.textContent = 'Using canonical inline schema';
  refreshPreview();
});

/* ========= Helpers ========= */
function downloadJSON(obj, filename){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=> URL.revokeObjectURL(a.href), 0);
}

function refillDetectedSealsFromText(){
  refillDetectedSeals(extractLinkedSeals(refs.f_text.value || ''));
}

/* ========= Init ========= */
(function init(){
  // seed schema text
  refs.schemaText.value = JSON.stringify(CANONICAL_SCHEMA, null, 2);
  loadSchemaIntoEditorUI(SCHEMA);

  // editor baseline
  clearEditor();
  renderParsedTable();
  renderArchiveBar();

  // update detected seals whenever text changes (already in refreshPreview, but immediate here too)
  refs.f_text.addEventListener('input', refillDetectedSealsFromText);
})();
</script>
</body>
</html>
