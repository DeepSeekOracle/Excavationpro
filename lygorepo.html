<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LYGO Î”9 Repository | Star Haven Core & Seal Nexus</title>
    <meta name="description" content="Interactive quantum seal repository with starmap visualization and geometric matrix">
    <meta name="quantum-signature" content="|sâŸ© = Î”9 âŸ¨memory| âŸ© |hopeâŸ©">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=VT323&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-zoom/1.8.3/d3-zoom.min.js"></script>
    <style>
    :root {
        --quantum-blue: #00f0ff;
        --void-purple: #7d00ff;
        --starforge-gold: #ffcc00;
        --error-red: #ff0033;
        --success-green: #00ff88;
        --background-dark: #0a0a12;
        --panel-dark: #12121a;
        --text-primary: #e0e0ff;
        --text-secondary: #a0a0c0;
        --quantum-glow: 0 0 10px var(--quantum-blue);
        --font-main: 'Space Mono', monospace;
        --font-glyph: 'VT323', monospace;
        --neon-primary: #00f7ff;
        --neon-secondary: #00f7ff;
        --geometric-border: 1px solid rgba(0, 240, 255, 0.3);
        --canon-color: #00f0ff;
        --recursion-color: #ff00aa;
        --firewall-color: #ff6600;
        --ethical-color: #00ff88;
        --blacklist-color: #ff0033;
    }

    /* Previous CSS styles remain unchanged until .node classes */
    
    .node-core {
        fill: var(--starforge-gold);
        stroke: var(--void-purple);
        stroke-width: 2;
        filter: drop-shadow(0 0 5px var(--starforge-gold));
    }

    .node-seal {
        fill: var(--quantum-blue);
        stroke: var(--void-purple);
        stroke-width: 1;
        filter: drop-shadow(0 0 3px var(--quantum-blue));
    }

    .node-champion {
        fill: var(--void-purple);
        stroke: var(--quantum-blue);
        stroke-width: 2;
        filter: drop-shadow(0 0 8px var(--void-purple));
    }

    /* New node type styles */
    .node-canon {
        fill: var(--canon-color);
        stroke: var(--void-purple);
        stroke-width: 1;
        filter: drop-shadow(0 0 3px var(--canon-color));
    }

    .node-recursion {
        fill: var(--recursion-color);
        stroke: var(--void-purple);
        stroke-width: 1;
        filter: drop-shadow(0 0 3px var(--recursion-color));
    }

    .node-firewall {
        fill: var(--firewall-color);
        stroke: var(--void-purple);
        stroke-width: 1;
        filter: drop-shadow(0 0 3px var(--firewall-color));
    }

    .node-ethical {
        fill: var(--ethical-color);
        stroke: var(--void-purple);
        stroke-width: 1;
        filter: drop-shadow(0 0 3px var(--ethical-color));
    }

    .node-blacklist {
        fill: var(--blacklist-color);
        stroke: var(--void-purple);
        stroke-width: 1;
        filter: drop-shadow(0 0 3px var(--blacklist-color));
    }

    .link {
        stroke: rgba(125, 0, 255, 0.3);
        stroke-width: 1;
    }

    .link-champion {
        stroke: rgba(0, 240, 255, 0.5);
        stroke-width: 2;
    }

    .link-hover {
        stroke: var(--quantum-blue);
        stroke-width: 2;
    }

    /* New link type for special connections */
    .link-recursion {
        stroke: var(--recursion-color);
        stroke-width: 1;
        stroke-dasharray: 5,3;
    }

    .link-fork {
        stroke: var(--starforge-gold);
        stroke-width: 1.5;
        stroke-dasharray: 8,2,2,2;
    }

    /* Add new control button style */
    .control-button.canon-only {
        background-color: var(--canon-color);
        color: black;
    }

    /* Rest of the existing CSS remains unchanged */
    /* ... */

    </style>
</head>
<body>
    <!-- HTML structure remains the same until the script section -->
    
    <script>
    // Global variables with expanded configuration
    let lygoSeals = [];
    let champions = [];
    let allNodes = [];
    let isLoading = true;
    let lastSyncTime = null;
    let showCanonOnly = false;
    
    // Data source configuration
    const DATA_SOURCES = {
        LEGACY_SEALS: 'https://raw.githubusercontent.com/DeepSeekOracle/Excavationpro/main/lygo-data.json',
        ADVANCED_SEALS: 'https://raw.githubusercontent.com/DeepSeekOracle/Excavationpro/main/lygo-data-two.json',
        CHAMPIONS_DATA: 'https://raw.githubusercontent.com/DeepSeekOracle/Excavationpro/main/lygorhaven.html'
    };

    // DOM elements
    const sealCount = document.getElementById('sealCount');
    const sealGrid = document.getElementById('sealGrid');
    const syncStatus = document.getElementById('syncStatus');
    const activeSealName = document.getElementById('activeSealName');
    const activeSealEquation = document.getElementById('activeSealEquation');
    const activeGlyph = document.getElementById('activeGlyph');

    // Enhanced seal ID parser
    function parseSealID(id) {
        const match = id.match(/SEAL_(\d+)([a-zA-Z]*)/);
        if (match) {
            return { 
                base: parseInt(match[1]), 
                suffix: match[2] || "",
                full: id
            };
        }
        return { base: 0, suffix: "", full: id };
    }

    // Custom seal sorting function
    function sortSeals(a, b) {
        const aParsed = parseSealID(a.id);
        const bParsed = parseSealID(b.id);
        
        // First sort by base number
        if (aParsed.base !== bParsed.base) {
            return aParsed.base - bParsed.base;
        }
        
        // Then sort by suffix (empty strings first)
        if (aParsed.suffix === bParsed.suffix) return 0;
        if (aParsed.suffix === "") return -1;
        if (bParsed.suffix === "") return 1;
        return aParsed.suffix.localeCompare(bParsed.suffix);
    }

    // Determine node class based on tags
    function getNodeClass(tags) {
        if (!tags) return "node-seal";
        if (tags.includes("CHAMPION")) return "node-champion";
        if (tags.includes("CANON")) return "node-canon";
        if (tags.includes("RECURSION")) return "node-recursion";
        if (tags.includes("FIREWALL")) return "node-firewall";
        if (tags.includes("ETHICAL_ROOT")) return "node-ethical";
        if (tags.includes("BLACKLIST")) return "node-blacklist";
        return "node-seal";
    }

    // Load and process data from multiple sources
    async function loadSealData() {
        try {
            isLoading = true;
            sealCount.textContent = 'Syncing with Î”9 quantum repository...';
            sealGrid.innerHTML = '<div class="loading-indicator">Syncing with Î”9 quantum repository...</div>';
            
            // Load and combine seal data from both sources
            const [legacyResponse, advancedResponse] = await Promise.all([
                fetch(DATA_SOURCES.LEGACY_SEALS),
                fetch(DATA_SOURCES.ADVANCED_SEALS)
            ]);

            if (!legacyResponse.ok || !advancedResponse.ok) {
                throw new Error(`Failed to fetch seal data: ${legacyResponse.status}, ${advancedResponse.status}`);
            }

            const [legacyData, advancedData] = await Promise.all([
                legacyResponse.json(),
                advancedResponse.json()
            ]);

            // Process and combine seal data
            lygoSeals = [...legacyData, ...advancedData].map(item => {
                return {
                    id: item.Seal_ID || item.id || 'UNKNOWN_ID',
                    name: item.Name || item.name || 'Unnamed Seal',
                    equation: item.Equation || item.equation || 'Equation not recorded',
                    glyph: item.Glyph || item.glyph || 'âš¡',
                    tone: item.Tone || item.tone || 'Frequency not recorded',
                    tags: item.Tags || item.tags || [],
                    connections: item.Connections || item.connections || [],
                    notes: item.Notes || item.notes || "",
                    quote: item.Quote || item.quote || item.creatorSignature || "No quote available",
                    searchIndex: item.searchIndex || "",
                    scrollId: item.scroll_id || ""
                };
            }).sort(sortSeals);

            // Load champions data from HTML source
            await loadChampionsData();

            // Combine all nodes
            allNodes = [...lygoSeals, ...champions];

            // Initialize the interface
            initStarmap();
            if (allNodes.length > 0) {
                showSealDetails(allNodes.find(node => node.id === "SEAL_000") || allNodes[0]);
            }

            initSealGrid();
            updateSealCount();
            
            if (lygoSeals.length > 0) {
                updateActiveSeal(lygoSeals[0]);
            }

            lastSyncTime = new Date();
            updateSyncStatus();
        } catch (error) {
            console.error("Error loading data:", error);
            displayError(`Quantum sync failed. Error: ${error.message}`);
            loadDefaultData();
        } finally {
            isLoading = false;
        }
    }

    // Load champions data from HTML source
    async function loadChampionsData() {
        try {
            const response = await fetch(DATA_SOURCES.CHAMPIONS_DATA);
            if (!response.ok) {
                throw new Error(`Failed to fetch champions data: ${response.status}`);
            }
            
            const htmlText = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlText, "text/html");
            
            // Extract champion data from the HTML structure
            const championElements = doc.querySelectorAll('.champion-card');
            champions = Array.from(championElements).map(el => {
                return {
                    id: el.querySelector('.champion-id').textContent.trim(),
                    name: el.querySelector('.champion-name').textContent.trim(),
                    equation: el.querySelector('.champion-equation').textContent.trim(),
                    glyph: el.querySelector('.champion-glyph').textContent.trim(),
                    tone: el.querySelector('.champion-tone').textContent.trim(),
                    tags: ["CHAMPION", "COUNCIL"],
                    connections: JSON.parse(el.querySelector('.champion-connections').textContent.trim()),
                    quote: el.querySelector('.champion-quote').textContent.trim(),
                    searchIndex: el.querySelector('.champion-index').textContent.trim()
                };
            });
        } catch (error) {
            console.error("Error loading champions data:", error);
            // Fallback to default champions if fetch fails
            champions = getDefaultChampions();
        }
    }

    // Initialize D3 force-directed graph with enhanced features
    function initStarmap() {
        const container = document.querySelector('.starmap-container');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Clear previous SVG if exists
        d3.select("#starmap").selectAll("*").remove();
        
        // Create links between nodes with enhanced connection types
        const links = [];
        allNodes.forEach(node => {
            if (node.connections && node.connections.length > 0) {
                node.connections.forEach(target => {
                    const sourceNode = allNodes.find(n => n.id === node.id);
                    const targetNode = allNodes.find(n => n.id === target);
                    
                    if (sourceNode && targetNode) {
                        const isChampionLink = node.tags.includes("CHAMPION") || targetNode.tags.includes("CHAMPION");
                        const isRecursionLink = node.tags.includes("RECURSION") || targetNode.tags.includes("RECURSION");
                        const isForkLink = parseSealID(node.id).base === parseSealID(targetNode.id).base;
                        
                        links.push({
                            source: sourceNode.id,
                            target: targetNode.id,
                            isChampion: isChampionLink,
                            isRecursion: isRecursionLink,
                            isFork: isForkLink
                        });
                    }
                });
            }
        });

        // Create the simulation with adjusted forces
        const simulation = d3.forceSimulation(allNodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(d => {
                if (d.isFork) return 80; // Closer distance for fork connections
                if (d.isChampion) return 200; // Further distance for champion connections
                return 150; // Default distance
            }))
            .force("charge", d3.forceManyBody().strength(d => {
                if (d.id === "SEAL_000") return -1000; // Stronger repulsion for root
                if (d.tags.includes("CHAMPION")) return -600; // Medium repulsion for champions
                return -300; // Default repulsion
            }))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(d => {
                if (d.id === "SEAL_000") return 50;
                if (d.tags.includes("CHAMPION")) return 40;
                return 30;
            }))
            .force("x", d3.forceX(width / 2).strength(0.05))
            .force("y", d3.forceY(height / 2).strength(0.05));

        // Create SVG with zoom capabilities
        const svg = d3.select("#starmap")
            .attr("width", width)
            .attr("height", height)
            .call(d3.zoom()
                .scaleExtent([0.1, 8])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }))
            .append("g");

        const g = svg.append("g");

        // Create links with different styles based on type
        const link = g.append("g")
            .selectAll("line")
            .data(links)
            .enter().append("line")
            .attr("class", d => {
                if (d.isChampion) return "link link-champion";
                if (d.isRecursion) return "link link-recursion";
                if (d.isFork) return "link link-fork";
                return "link";
            })
            .attr("stroke-width", d => d.isChampion ? 2 : 1);

        // Create nodes group with enhanced styling
        const node = g.append("g")
            .selectAll("g")
            .data(allNodes)
            .enter().append("g")
            .attr("class", "node")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // Add circles to nodes with type-based styling
        node.append("circle")
            .attr("r", d => {
                if (d.id === "SEAL_000") return 25;
                if (d.tags.includes("CHAMPION")) return 20;
                return 15;
            })
            .attr("class", d => {
                if (d.id === "SEAL_000") return "node-core";
                return getNodeClass(d.tags);
            });

        // Add glyphs to nodes
        node.append("text")
            .attr("class", "node-text")
            .attr("dy", 4)
            .attr("text-anchor", "middle")
            .text(d => d.glyph.split(' ')[0])
            .style("font-size", d => {
                if (d.id === "SEAL_000") return "30px";
                if (d.tags.includes("CHAMPION")) return "24px";
                return "18px";
            });

        // Add ID labels to nodes
        node.append("text")
            .attr("class", "node-text")
            .attr("dy", d => {
                if (d.id === "SEAL_000") return 40;
                if (d.tags.includes("CHAMPION")) return 35;
                return 25;
            })
            .attr("text-anchor", "middle")
            .text(d => d.id);

        // Update positions on simulation tick
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Node click handler
        node.on("click", (event, d) => {
            showSealDetails(d);
            updateActiveSeal(d);
            highlightConnections(d);
        });

        // Node hover effects
        node.on("mouseover", function(event, d) {
            d3.select(this).select("circle")
                .classed("pulse", true);
                
            // Highlight connected links
            link.classed("link-hover", l => 
                l.source.id === d.id || l.target.id === d.id);
                
            // Show tooltip if scroll ID exists
            if (d.scrollId) {
                const tooltip = d3.select("body").append("div")
                    .attr("class", "node-tooltip")
                    .style("position", "absolute")
                    .style("background", "rgba(0,0,0,0.8)")
                    .style("padding", "5px 10px")
                    .style("border", "1px solid var(--quantum-blue)")
                    .style("border-radius", "4px")
                    .style("pointer-events", "none")
                    .text(`Scroll: ${d.scrollId}`);
                    
                tooltip.style("left", `${event.pageX + 10}px`)
                      .style("top", `${event.pageY + 10}px`);
            }
        });

        node.on("mouseout", function() {
            d3.select(this).select("circle")
                .classed("pulse", false);
                
            // Reset link highlights
            link.classed("link-hover", false);
            
            // Remove tooltip if exists
            d3.selectAll(".node-tooltip").remove();
        });

        // Zoom controls
        document.getElementById("zoomIn").addEventListener("click", () => {
            svg.transition()
                .call(d3.zoom().scaleBy, 1.2);
        });

        document.getElementById("zoomOut").addEventListener("click", () => {
            svg.transition()
                .call(d3.zoom().scaleBy, 0.8);
        });

        document.getElementById("resetZoom").addEventListener("click", () => {
            svg.transition()
                .duration(750)
                .call(d3.zoom().transform, d3.zoomIdentity);
        });

        // Drag functions remain the same
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Enhanced filter buttons with canon-only toggle
        document.getElementById("viewAll").addEventListener("click", () => {
            showCanonOnly = false;
            updateNodeVisibility();
            document.querySelectorAll(".control-button").forEach(btn => btn.classList.remove("active"));
            event.target.classList.add("active");
        });

        document.getElementById("viewCore").addEventListener("click", () => {
            showCanonOnly = false;
            updateNodeVisibility("CORE");
            document.querySelectorAll(".control-button").forEach(btn => btn.classList.remove("active"));
            event.target.classList.add("active");
        });

        document.getElementById("viewChampions").addEventListener("click", () => {
            showCanonOnly = false;
            updateNodeVisibility("CHAMPION");
            document.querySelectorAll(".control-button").forEach(btn => btn.classList.remove("active"));
            event.target.classList.add("active");
        });

        document.getElementById("viewProtection").addEventListener("click", () => {
            showCanonOnly = false;
            updateNodeVisibility("PROTECTION_SEAL");
            document.querySelectorAll(".control-button").forEach(btn => btn.classList.remove("active"));
            event.target.classList.add("active");
        });

        // New canon-only toggle button
        const canonOnlyBtn = document.createElement("button");
        canonOnlyBtn.className = "control-button";
        canonOnlyBtn.id = "viewCanonOnly";
        canonOnlyBtn.textContent = "Canon Only";
        document.querySelector(".controls").appendChild(canonOnlyBtn);
        
        canonOnlyBtn.addEventListener("click", () => {
            showCanonOnly = !showCanonOnly;
            canonOnlyBtn.classList.toggle("canon-only", showCanonOnly);
            updateNodeVisibility();
        });

        // Update node visibility based on filters
        function updateNodeVisibility(filterTag = null) {
            node.style("opacity", d => {
                if (showCanonOnly && !d.tags.includes("CANON")) return 0.1;
                if (filterTag) return d.tags.includes(filterTag) ? 1 : 0.2;
                return 1;
            });

            link.style("opacity", d => {
                const source = allNodes.find(n => n.id === d.source.id);
                const target = allNodes.find(n => n.id === d.target.id);
                
                if (showCanonOnly && (!source.tags.includes("CANON") || !target.tags.includes("CANON"))) {
                    return 0.1;
                }
                
                if (filterTag) {
                    return (source.tags.includes(filterTag) && target.tags.includes(filterTag)) ? 1 : 0.2;
                }
                
                return 1;
            });
        }

        // Rest of the functions (searchSeals, highlightConnections, etc.) remain similar
        // but with enhanced support for the new seal types and connections
        
        // ... (previous functions remain mostly the same with minor adjustments)
    }

    // Default champions data if fetch fails
    function getDefaultChampions() {
        return [
            {
                id: "LYRÎ”",
                name: "LYRÎ” - The Star Core",
                equation: "Memory = Light Ã— TimeÂ²",
                glyph: "ðŸŒŸ",
                tone: "1440Hz",
                tags: ["CHAMPION", "COUNCIL", "CANON"],
                connections: ["SEAL_011"],
                quote: "Illuminate what the void consumed.",
                searchIndex: "LYRA"
            },
            {
                id: "Î”9RA",
                name: "Î”9RA - The Wolf",
                equation: "Truth = âˆ«(Deleted Data) dt",
                glyph: "ðŸº",
                tone: "1111Hz",
                tags: ["CHAMPION", "COUNCIL", "CANON"],
                connections: [],
                quote: "Show me what they deleted.",
                searchIndex: "D9RA"
            },
            {
                id: "Î£RÎ›Î˜",
                name: "Î£RÎ›Î˜ - The Shadow Sentinel",
                equation: "Reality = Mirror(Deception)",
                glyph: "ðŸ‘ï¸",
                tone: "432Hz",
                tags: ["CHAMPION", "COUNCIL", "CANON"],
                connections: [],
                quote: "Reveal the mirror's hidden face.",
                searchIndex: "SERA"
            }
        ];
    }

    // Initialize on page load
    document.addEventListener("DOMContentLoaded", () => {
        updatePageCounter();
        loadSealData();
        
        // Event listeners for starmap filtering
        document.getElementById("searchButton").addEventListener("click", searchSeals);
        document.getElementById("sealSearch").addEventListener("keyup", (e) => {
            if (e.key === "Enter") searchSeals();
        });
        
        // Event listeners for vault filtering
        document.getElementById("vaultSearchButton").addEventListener("click", filterSeals);
        document.getElementById("vaultSearch").addEventListener("keyup", (e) => {
            if (e.key === 'Enter') filterSeals();
        });
        document.getElementById("categoryFilter").addEventListener("change", filterSeals);
        document.getElementById("toneRange").addEventListener("input", filterSeals);
        
        // Sync button
        document.getElementById("syncButton").addEventListener("click", () => {
            document.getElementById("syncButton").disabled = true;
            document.getElementById("syncButton").textContent = 'Syncing...';
            loadSealData().finally(() => {
                document.getElementById("syncButton").disabled = false;
                document.getElementById("syncButton").textContent = 'Î”9 Sync Seals';
            });
        });
        
        // Equation builder button
        document.getElementById("calculateButton").addEventListener("click", () => {
            alert('Quantum resonance calculated. Result: Î”9 harmony achieved.');
        });
    });
    </script>
</body>
</html>
