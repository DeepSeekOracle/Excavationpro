<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>SEALMAKER — Canonical Mode</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0b0f14; --panel:#0f161d; --panel2:#0c1319; --text:#e6edf3; --muted:#9fb0bd;
    --accent:#00ff88; --accent2:#00d1ff; --danger:#ef4444; --ok:#22c55e; --border:#20303b; --chip:#131c23; --grid:rgba(0,255,136,.08);
    --font: "Space Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text); background:
      radial-gradient(1100px 600px at 110% -10%, rgba(0,209,255,.09), transparent 60%),
      radial-gradient(900px 500px at -10% 110%, rgba(0,255,136,.08), transparent 60%),
      var(--bg);
    font: 14px/1.5 var(--font);
    overflow-x:hidden;
  }
  .quantum-grid{position:fixed; inset:0; pointer-events:none; z-index:0;}
  .quantum-grid::after{
    content:""; position:absolute; inset:0;
    background-image:
      linear-gradient(to right, var(--grid) 1px, transparent 1px),
      linear-gradient(to bottom, var(--grid) 1px, transparent 1px);
    background-size:40px 40px;
    mask-image: radial-gradient(circle at 50% 20%, rgba(0,0,0,1), rgba(0,0,0,.5) 55%, rgba(0,0,0,0) 80%);
  }
  #matrix{position:fixed; inset:0; z-index:0; pointer-events:none;}

  .container{position:relative; z-index:1; max-width:1250px; margin:0 auto; padding:22px;}
  h1,h2,h3{margin:0 0 .5rem}
  .muted{color:var(--muted)}
  .space{height:10px}

  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,.02), transparent 40%), var(--panel);
    border:1px solid var(--border); border-radius:12px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
  }
  .panel-header{padding:12px 14px; border-bottom:1px solid var(--border); display:flex; align-items:center; justify-content:space-between}
  .panel-body{padding:14px}

  .btn{border:1px solid var(--border); background:var(--panel2); color:var(--text); padding:8px 10px; border-radius:8px; cursor:pointer;}
  .btn:hover{filter:brightness(1.1)}
  .btn:disabled{opacity:.5; cursor:default}
  .btn-accent{border-color:rgba(0,255,136,.35); background:linear-gradient(180deg, rgba(0,255,136,.15), transparent 60%), var(--panel2)}
  .btn-danger{border-color:rgba(239,68,68,.35); background:linear-gradient(180deg, rgba(239,68,68,.15), transparent 60%), var(--panel2)}
  .chip{display:inline-flex; align-items:center; gap:6px; padding:3px 10px; border-radius:999px; background:var(--chip); border:1px solid var(--border); font-size:12px}
  .toolbar{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .sep{width:1px; height:28px; background:var(--border)}

  input[type="text"], input[type="url"], input[type="search"], select, textarea{
    width:100%; background:#0b1117; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:8px 10px; outline:none;
  }
  textarea{min-height:110px; resize:vertical}
  label{display:block; font-size:12px; color:var(--muted); margin:10px 0 6px}

  .row{display:grid; grid-template-columns: 380px 1fr; gap:16px}
  @media (max-width:1000px){ .row{grid-template-columns:1fr} }

  .dropzone{ border:2px dashed var(--border); border-radius:10px; padding:16px; background:#0b1117; text-align:center; cursor:pointer; }
  .dropzone.dragover{border-color:var(--accent); background:#0c151a}

  table{width:100%; border-collapse:collapse}
  th,td{padding:10px; border-bottom:1px solid var(--border); vertical-align:top; text-align:left}
  th{color:var(--muted); font-weight:700; font-size:12px; letter-spacing:.03em; user-select:none; cursor:pointer;}
  th.sorting{color:var(--text)}
  th .dir{opacity:.7; font-size: 11px;}
  .right{text-align:right}

  .json{background:#0b1117; border:1px solid var(--border); border-radius:8px; padding:10px; white-space:pre; overflow:auto; max-height:320px; font-size:12px}
  .status-ok{color:#bbf7d0}
  .status-bad{color:#fecaca}
  .hash{font-size:12px; word-break:break-all}

  details.schema{background:#0b1117; border:1px solid var(--border); border-radius:8px; padding:10px}
  details.schema summary{cursor:pointer; color:var(--muted); margin-bottom:8px}
  details.schema textarea{height:220px}

  .hintbar{min-height:20px; font-size:12px; color:var(--muted); padding:4px 0}
  .tooltip{position:absolute; pointer-events:none; background:var(--panel2); border:1px solid var(--border); padding:8px; border-radius:8px; font-size:12px; max-width:280px; display:none; z-index:10}

  .suggest{position:absolute; background:var(--panel2); border:1px solid var(--border); border-radius:8px; box-shadow:0 10px 24px rgba(0,0,0,.25); z-index:10; display:none; max-height:180px; overflow:auto}
  .suggest button{display:block; width:100%; text-align:left; background:transparent; border:none; color:var(--text); padding:6px 10px; cursor:pointer}
  .suggest button:hover{background:rgba(255,255,255,.06)}

  .mini-preview{position:fixed; pointer-events:none; background:var(--panel2); border:1px solid var(--border); border-radius:8px; padding:8px; font-size:12px; display:none; z-index:20; max-width:300px}
  .mini-preview .title{font-weight:700}
  .mini-preview .line{opacity:.8}

  .tabs{display:flex; gap:8px; border-bottom:1px solid var(--border); padding:0 14px 8px}
  .tab{padding:6px 10px; border-radius:6px; cursor:pointer; border:1px solid transparent}
  .tab.active{border-color:var(--border); background:var(--panel2)}
</style>
</head>
<body>
  <canvas id="matrix"></canvas>
  <div class="quantum-grid"></div>
  <div id="tooltip" class="tooltip"></div>
  <div id="miniPreview" class="mini-preview"></div>
  <div id="suggestBox" class="suggest"></div>

  <div class="container">
    <!-- PHASE 1: Recovery Banner -->
    <section id="recovery" class="panel" style="display:none; margin-bottom:12px;">
      <div class="panel-body" style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
        <strong>Restore previous session?</strong>
        <span class="muted" id="recoveryMeta"></span>
        <button id="btnRecover" class="btn btn-accent">Restore</button>
        <button id="btnDismissRecovery" class="btn">Dismiss</button>
        <button id="btnClearSavedSession" class="btn btn-danger" title="Delete saved snapshot from localStorage">Clear Saved Session</button>
      </div>
    </section>

    <header class="panel">
      <div class="panel-header">
        <div>
          <h1>SEALMAKER — Canonical Mode</h1>
          <div class="muted">Import • Edit • Validate • Preview • Export • Autosave</div>
        </div>
        <div class="toolbar">
          <span class="chip">Seals in archive: <strong id="archiveCount">0</strong></span>
          <input id="jsonFile" type="file" accept=".json,application/json" style="display:none" />
          <input id="txtFile" type="file" accept=".txt,text/plain" multiple style="display:none" />
          <button id="btnImportJson" class="btn">Import .json</button>
          <button id="btnImportTxt" class="btn">Import .txt</button>
          <button id="btnLoadDemo" class="btn">Load Demo Seals</button>
          <div class="sep"></div>
          <select id="exportShape" title="Export format">
            <option value="object" selected>{ "seals": [...] }</option>
            <option value="array">[ ... ]</option>
          </select>
          <button id="btnExportArchive" class="btn btn-accent" disabled>Export lygo-data-two.json</button>
          <button id="btnExportPDF" class="btn">Export PDF (Scroll)</button>
          <button id="btnClearArchive" class="btn btn-danger" disabled>Clear Archive</button>
          <div class="sep"></div>
          <button id="btnToggleRain" class="btn" title="Toggle Matrix Rain">Matrix: On</button>
        </div>
      </div>
      <div class="panel-body" style="display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
        <span class="chip">Autosave: <span id="autosaveStatus" class="muted">idle</span></span>
        <span class="chip">PHASES: 1 ✓ 2 ✓ 3 ✓</span>
      </div>
    </header>

    <div class="space"></div>

    <section class="panel">
      <div class="tabs">
        <div class="tab active" data-tab="builder">Builder</div>
        <div class="tab" data-tab="extras">Extras</div>
      </div>
      <div class="panel-body" id="tab-builder">
        <div class="row">
          <!-- Left: Filters & Import -->
          <section class="panel">
            <div class="panel-header">
              <h3>Filters & Import</h3>
              <div class="toolbar">
                <span class="chip">Parsed: <strong id="parsedCount">0</strong></span>
                <button id="btnAppendAll" class="btn">Append All Parsed → Archive</button>
                <button id="btnClearParsed" class="btn btn-danger" disabled>Clear Parsed</button>
              </div>
            </div>
            <div class="panel-body">
              <!-- PHASE 1: Multi-select Filters -->
              <div class="grid" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label>Tag filter (multi)</label>
                  <select id="tagFilter" multiple size="6" title="Filter archive by any selected tag"></select>
                  <div class="toolbar"><button id="btnClearTagFilter" class="btn">Clear</button></div>
                </div>
                <div>
                  <label>Tone filter (multi)</label>
                  <select id="toneFilter" multiple size="6" title="Filter archive by any selected tone"></select>
                  <div class="toolbar"><button id="btnClearToneFilter" class="btn">Clear</button></div>
                </div>
              </div>

              <div class="space"></div>
              <div id="dropzone" class="dropzone">Drag & drop .json/.txt files here</div>

              <div class="space"></div>
              <label>Paste TXT (one or multiple seals)</label>
              <textarea id="pasteArea" placeholder="Paste raw seal text..."></textarea>
              <div class="toolbar">
                <select id="splitStrategy">
                  <option value="none">Do not split (single)</option>
                  <option value="blank">2+ blank lines</option>
                  <option value="hr">Lines of ---</option>
                </select>
                <button id="btnParsePaste" class="btn btn-accent">Parse Pasted Text</button>
                <button id="btnClearPaste" class="btn">Clear</button>
              </div>
            </div>
          </section>

          <!-- Right: Editor + Preview -->
          <section class="panel">
            <div class="panel-header">
              <h3>Seal Editor</h3>
              <div class="toolbar">
                <span id="entryStatus" class="chip">No seal selected</span>
                <button id="btnAppendOne" class="btn" disabled>Append to Archive</button>
                <button id="btnDownloadOne" class="btn" disabled>Download Seal .json</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="hintbar" id="hintbar">Hover or focus a field to see hints.</div>

              <div class="grid" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label data-hint="Unique stable identifier, e.g., SEAL_014">id</label>
                  <input id="f_id" type="text" placeholder="SEAL_001" />
                </div>
                <div>
                  <label data-hint="Short, descriptive name">title</label>
                  <input id="f_title" type="text" placeholder="Seal Title" />
                </div>
              </div>

              <label data-hint="Symbolic or math-like relation that encodes the seal essence">equation</label>
              <input id="f_equation" type="text" placeholder="E.g., ∑(n=1..k) ..." />

              <div class="grid" style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px;">
                <div>
                  <label data-hint="Emotional/energetic tone, e.g., bright/dark/neutral">tone</label>
                  <input id="f_tone" list="toneList" type="text" placeholder="neutral" />
                  <datalist id="toneList">
                    <option value="neutral"></option>
                    <option value="bright"></option>
                    <option value="dark"></option>
                    <option value="solar"></option>
                    <option value="lunar"></option>
                    <option value="void"></option>
                  </datalist>
                </div>
                <div>
                  <label data-hint="Unicode glyph or ID referencing the sigil graphic">glyph</label>
                  <input id="f_glyph" type="text" placeholder="Ψ / ᚠ / GLYPH_ID" />
                </div>
                <div>
                  <label data-hint="ISO 8601 date-time">date (ISO)</label>
                  <div class="toolbar">
                    <input id="f_date" type="text" placeholder="2025-08-12T23:59:59Z" style="flex:1" />
                    <button id="btnNow" class="btn">Now</button>
                  </div>
                </div>
              </div>

              <div class="grid" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label data-hint="Comma-separated tags for filtering and themes">tags</label>
                  <input id="f_tags" type="text" placeholder="bootstrap, sovereign_mode" />
                </div>
                <div style="position:relative">
                  <!-- PHASE 2: Autocomplete -->
                  <label data-hint="Comma-separated seal IDs; suggestions from archive appear as you type">linked_seals</label>
                  <input id="f_linked" type="text" placeholder="SEAL_014, SEAL_273X" autocomplete="off" />
                </div>
              </div>

              <div class="grid" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label data-hint="Short quote or mantra aligned to the seal">quote</label>
                  <textarea id="f_quote" placeholder="&quot;Short pull-quote.&quot;"></textarea>
                </div>
                <div>
                  <!-- PHASE 2: Markdown Preview -->
                  <label data-hint="Long notes in Markdown. Supports **bold**, _italics_, `code`, images and links.">notes</label>
                  <textarea id="f_notes" placeholder="Markdown-supported notes"></textarea>
                </div>
              </div>

              <div>
                <label data-hint="Media attachments with type + URL">media_links</label>
                <div id="mediaList"></div>
                <div class="toolbar">
                  <select id="mediaType">
                    <option value="image">image</option>
                    <option value="gif">gif</option>
                    <option value="video">video</option>
                    <option value="audio">audio</option>
                    <option value="other">other</option>
                  </select>
                  <input id="mediaUrl" type="url" placeholder="https://..." style="flex:1" />
                  <button id="btnAddMedia" class="btn">Add</button>
                </div>
                <div class="hint muted">Each item: { type, url }</div>
              </div>

              <div class="space"></div>
              <h3>JSON Preview</h3>
              <pre id="jsonPreview" class="json">{}</pre>
              <div class="hint">
                <span id="validBadge" class="status-bad">invalid</span> • Live validation
              </div>
              <!-- PHASE 2: SHA field -->
              <label>SHA-256</label>
              <input id="hashField" type="text" readonly placeholder="…" />

              <div class="space"></div>
              <h3>Notes Preview</h3>
              <div id="notesPreview" class="panel" style="padding:12px; overflow:auto; max-height:260px;"></div>
            </div>
          </section>
        </div>

        <div class="space"></div>

        <!-- Parsed & Archive Tables -->
        <section class="panel">
          <div class="panel-header">
            <h3>Parsed Seals</h3>
            <div class="toolbar">
              <span class="chip">Count: <strong id="parsedCount2">0</strong></span>
            </div>
          </div>
          <div class="panel-body" style="padding-top:0">
            <table>
              <thead><tr>
                <th>#</th><th>ID</th><th>Title</th><th>Tone</th><th>Tags</th><th>Linked</th><th>Date</th><th class="right">Actions</th>
              </tr></thead>
              <tbody id="parsedBody"></tbody>
            </table>
          </div>
        </section>

        <div class="space"></div>

        <section class="panel">
          <div class="panel-header">
            <h3>Archive</h3>
            <div class="toolbar">
              <!-- PHASE 3: Loop detector covers archive + parsed -->
              <span id="cycleWarn" class="chip">Links: clean</span>
            </div>
          </div>
          <div class="panel-body" style="padding-top:0">
            <table>
              <thead>
                <tr>
                  <th data-sort="id">ID <span class="dir"></span></th>
                  <th data-sort="title">Title <span class="dir"></span></th>
                  <th data-sort="tone">Tone <span class="dir"></span></th>
                  <th data-sort="tags">Tags <span class="dir"></span></th>
                  <th data-sort="linked">Linked <span class="dir"></span></th>
                  <th data-sort="date">Date <span class="dir"></span></th>
                  <th class="right">Actions</th>
                </tr>
              </thead>
              <tbody id="archiveBody"></tbody>
            </table>
          </div>
        </section>
      </div>

      <!-- PHASE 3: Extras -->
      <div class="panel-body" id="tab-extras" style="display:none;">
        <div class="grid" style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
          <section class="panel">
            <div class="panel-header">
              <h3>Seal Schema (inline)</h3>
              <div class="toolbar">
                <span id="schemaStatus" class="chip">Active</span>
                <button id="btnResetSchema" class="btn">Reset Schema</button>
                <button id="btnApplySchema" class="btn btn-accent">Apply Pasted Schema</button>
              </div>
            </div>
            <div class="panel-body">
              <details class="schema">
                <summary>Show/Hide Schema JSON</summary>
<textarea id="schemaText"></textarea>
                <div class="hint">This schema validates seals and informs tooltips.</div>
              </details>
            </div>
          </section>

          <section class="panel">
            <div class="panel-header">
              <h3>Upload Dataset (GitHub API / HF via GitHub)</h3>
            </div>
            <div class="panel-body">
              <div class="hint">Optional online feature. Requires a GitHub PAT with repo access. Uses GitHub Contents API. May be blocked by CORS.</div>
              <label>Repository (owner/repo)</label>
              <input id="ghRepo" type="text" placeholder="yourname/your-repo" />
              <div class="grid" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label>Branch</label>
                  <input id="ghBranch" type="text" value="main" />
                </div>
                <div>
                  <label>Path</label>
                  <input id="ghPath" type="text" value="lygo-data-two.json" />
                </div>
              </div>
              <label>Commit message</label>
              <input id="ghMessage" type="text" value="Update lygo-data-two.json from SEALMAKER" />
              <label>GitHub Token (kept in memory only)</label>
              <input id="ghToken" type="text" placeholder="ghp_..." />
              <div class="toolbar">
                <button id="btnPushGH" class="btn btn-accent">Upload Dataset</button>
                <button id="btnCheckGH" class="btn">Check Remote</button>
              </div>
              <pre id="ghLog" class="json" style="max-height:200px;"></pre>
            </div>
          </section>
        </div>
      </div>
    </section>
  </div>

<script>
// ========== Matrix Rain ==========
const rain = { running:true, started:false, cols:[], size:14, w:0, h:0, ctx:null, raf:0 };
function initRain(){
  const c = document.getElementById('matrix');
  const ctx = c.getContext('2d');
  c.width = window.innerWidth; c.height = window.innerHeight;
  rain.w = c.width; rain.h = c.height; rain.ctx = ctx;
  rain.size = Math.max(12, Math.min(20, Math.round(window.innerWidth/120)));
  const columns = Math.ceil(rain.w / rain.size);
  rain.cols = new Array(columns).fill(0).map(()=> Math.floor(Math.random()*rain.h/rain.size));
  ctx.font = rain.size + 'px monospace'; ctx.textBaseline='top';
}
function startRain(){
  if (rain.started) return; rain.started = true; initRain();
  const glyphs='アァカサタナハマヤャラワ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const step=()=>{
    if (!rain.running){ rain.raf = requestAnimationFrame(step); return; }
    const ctx = rain.ctx;
    ctx.fillStyle='rgba(0,0,0,.12)'; ctx.fillRect(0,0,rain.w,rain.h);
    for (let i=0;i<rain.cols.length;i++){
      const x=i*rain.size, y=rain.cols[i]*rain.size;
      ctx.fillStyle='rgba(0,255,136,.95)'; ctx.fillText(glyphs.charAt((Math.random()*glyphs.length)|0), x,y);
      ctx.fillStyle='rgba(0,209,255,.6)'; ctx.fillText(glyphs.charAt((Math.random()*glyphs.length)|0), x, y-rain.size);
      if (y>rain.h && Math.random()>0.975) rain.cols[i]=0; else rain.cols[i]+=1;
    }
    rain.raf=requestAnimationFrame(step);
  };
  rain.raf=requestAnimationFrame(step);
  window.addEventListener('resize', ()=>{ cancelAnimationFrame(rain.raf); rain.started=false; initRain(); startRain(); });
}
startRain();
document.getElementById('btnToggleRain').addEventListener('click', e=>{
  rain.running=!rain.running; e.target.textContent='Matrix: '+(rain.running?'On':'Off');
});

// ========== Schema ==========
const DEFAULT_SEAL_SCHEMA = {
  "$schema":"http://json-schema.org/draft-07/schema#",
  "title":"LYRA_SEAL_ENTRY",
  "type":"object",
  "properties":{
    "id":{"type":"string"},
    "title":{"type":"string"},
    "equation":{"type":"string"},
    "tone":{"type":"string"},
    "glyph":{"type":"string"},
    "tags":{"type":"array","items":{"type":"string"}},
    "linked_seals":{"type":"array","items":{"type":"string"}},
    "quote":{"type":"string"},
    "notes":{"type":"string"},
    "media_links":{
      "type":"array","items":{
        "type":"object","properties":{
          "type":{"type":"string","enum":["image","gif","video","audio","other"]},
          "url":{"type":"string","format":"uri"}
        },"required":["type","url"]
      }
    },
    "date":{"type":"string","format":"date-time"},
    "seal_hash":{"type":"string"} /* optional */
  },
  "required":["id","title","date"]
};
let SCHEMA = JSON.parse(JSON.stringify(DEFAULT_SEAL_SCHEMA));

// ========== Refs ==========
const $ = (s,r=document)=>r.querySelector(s);
const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));

const refs = {
  // header
  jsonFile: $('#jsonFile'), txtFile: $('#txtFile'),
  btnImportJson: $('#btnImportJson'), btnImportTxt: $('#btnImportTxt'),
  btnLoadDemo: $('#btnLoadDemo'), btnExportArchive: $('#btnExportArchive'), btnClearArchive: $('#btnClearArchive'),
  exportShape: $('#exportShape'), archiveCount: $('#archiveCount'), btnExportPDF: $('#btnExportPDF'),
  btnToggleRain: $('#btnToggleRain'),
  // autosave
  autosaveStatus: $('#autosaveStatus'),
  // recovery
  recovery: $('#recovery'), recoveryMeta: $('#recoveryMeta'), btnRecover: $('#btnRecover'),
  btnDismissRecovery: $('#btnDismissRecovery'), btnClearSavedSession: $('#btnClearSavedSession'),
  // tabs
  tabs: $$('.tab'),
  // filters/import
  dropzone: $('#dropzone'), pasteArea: $('#pasteArea'), splitStrategy: $('#splitStrategy'),
  btnParsePaste: $('#btnParsePaste'), btnClearPaste: $('#btnClearPaste'), btnAppendAll: $('#btnAppendAll'), btnClearParsed: $('#btnClearParsed'),
  parsedCount: $('#parsedCount'), parsedCount2: $('#parsedCount2'),
  tagFilter: $('#tagFilter'), toneFilter: $('#toneFilter'), btnClearTagFilter: $('#btnClearTagFilter'), btnClearToneFilter: $('#btnClearToneFilter'),
  // editor
  entryStatus: $('#entryStatus'), f_id: $('#f_id'), f_title: $('#f_title'), f_equation: $('#f_equation'), f_tone: $('#f_tone'),
  f_glyph: $('#f_glyph'), f_tags: $('#f_tags'), f_linked: $('#f_linked'), f_quote: $('#f_quote'), f_notes: $('#f_notes'),
  f_date: $('#f_date'), mediaList: $('#mediaList'), mediaType: $('#mediaType'), mediaUrl: $('#mediaUrl'), btnAddMedia: $('#btnAddMedia'),
  btnNow: $('#btnNow'), btnAppendOne: $('#btnAppendOne'), btnDownloadOne: $('#btnDownloadOne'),
  jsonPreview: $('#jsonPreview'), validBadge: $('#validBadge'), notesPreview: $('#notesPreview'), hashField: $('#hashField'),
  hintbar: $('#hintbar'),
  // tables
  parsedBody: $('#parsedBody'), archiveBody: $('#archiveBody'), cycleWarn: $('#cycleWarn'),
  // extras / GH
  ghRepo: $('#ghRepo'), ghBranch: $('#ghBranch'), ghPath: $('#ghPath'), ghMessage: $('#ghMessage'), ghToken: $('#ghToken'),
  btnPushGH: $('#btnPushGH'), btnCheckGH: $('#btnCheckGH'), ghLog: $('#ghLog'),
  // schema
  schemaText: $('#schemaText'), btnApplySchema: $('#btnApplySchema'), btnResetSchema: $('#btnResetSchema'), schemaStatus: $('#schemaStatus'),
};

// ========== State ==========
let parsedSeals = [];
let archive = [];
let currentIndex = -1;
let sortKey='id', sortDir=1; // 1 asc, -1 desc

// ========== Helpers ==========
function nowISO(){ return new Date().toISOString(); }
function cleanText(t){ return (t||'').replace(/^\uFEFF/,'').replace(/\r\n?/g,'\n').trim(); }
function firstNonEmptyLine(t){ return (t.split('\n').map(s=>s.trim()).find(Boolean)||'').trim(); }
function escapeHtml(s=''){ return s.replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function escapeAttr(s=''){ return escapeHtml(s).replace(/"/g,'&quot;'); }
function safeName(s){ return (s||'seal').replace(/[^\w\-]+/g,'_').slice(0,64); }
function structuredCloneSafe(x){ return window.structuredClone ? window.structuredClone(x) : JSON.parse(JSON.stringify(x)); }
function isISO(s){ return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+\-]\d{2}:\d{2})$/.test(s||''); }
function isURI(s){ try{ const u=new URL(s); return !!u.protocol && !!u.host; }catch{ return false; } }
function base64EncodeUtf8(str){ return btoa(unescape(encodeURIComponent(str))); }

// ========== PHASE 1: LocalStorage Autosave + Restore ==========
const LS_KEY='SEAL_ARCHIVE_LYRA';
function saveArchiveLS(){
  try{
    const snap = { savedAt: nowISO(), seals: archive };
    localStorage.setItem(LS_KEY, JSON.stringify(snap));
    refs.autosaveStatus.textContent = 'saved ' + new Date().toLocaleTimeString();
  }catch(e){
    refs.autosaveStatus.textContent = 'save failed';
  }
}
function loadArchiveFromLS(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return null;
    return JSON.parse(raw);
  }catch{ return null; }
}
function showRecoveryIfAvailable(){
  const snap = loadArchiveFromLS();
  if (snap && Array.isArray(snap.seals) && snap.seals.length){
    refs.recoveryMeta.textContent = `Saved at ${snap.savedAt}, entries: ${snap.seals.length}`;
    refs.recovery.style.display = 'block';
    refs.btnRecover.onclick = ()=>{ archive = snap.seals; renderArchive(); updateFiltersFromArchive(); detectCycles(); refs.recovery.style.display='none'; };
    refs.btnDismissRecovery.onclick = ()=> refs.recovery.style.display='none';
    refs.btnClearSavedSession.onclick = ()=>{ localStorage.removeItem(LS_KEY); refs.recovery.style.display='none'; };
  }
}
console.log('PHASE 1 ready');

// ========== PHASE 1: Multi-select filters ==========
function getSelectedValues(sel){ return Array.from(sel.selectedOptions).map(o=>o.value); }
function updateFiltersFromArchive(){
  const allTags = new Set(); const allTones = new Set();
  archive.forEach(s=>{
    (s.tags||[]).forEach(t=> allTags.add(t));
    if (s.tone) allTones.add(s.tone);
  });
  const tagVals = Array.from(allTags).sort();
  const toneVals = Array.from(allTones).sort();
  refs.tagFilter.innerHTML = tagVals.map(t=>`<option value="${escapeAttr(t)}">${escapeHtml(t)}</option>`).join('');
  refs.toneFilter.innerHTML = toneVals.map(t=>`<option value="${escapeAttr(t)}">${escapeHtml(t)}</option>`).join('');
}
refs.tagFilter.addEventListener('change', renderArchive);
refs.toneFilter.addEventListener('change', renderArchive);
$('#btnClearTagFilter').addEventListener('click', ()=>{ Array.from(refs.tagFilter.options).forEach(o=>o.selected=false); renderArchive(); });
$('#btnClearToneFilter').addEventListener('click', ()=>{ Array.from(refs.toneFilter.options).forEach(o=>o.selected=false); renderArchive(); });

// ========== Validation ==========
function validateSeal(seal, schema=SCHEMA){
  const errors=[];
  if (!seal || typeof seal!=='object') return {ok:false, errors:['Seal is not an object']};
  (schema.required||[]).forEach(k=>{ if(!(k in seal)) errors.push(`Missing required "${k}"`); });
  const props = schema.properties||{};
  function check(key, val, def){
    if (!def) return;
    const t=def.type;
    if (!t) return;
    if (t==='string'){
      if (typeof val!=='string') errors.push(`"${key}" must be string`);
      if (def.format==='date-time' && typeof val==='string' && !isISO(val)) errors.push(`"${key}" must be ISO date-time`);
      if (def.format==='uri' && typeof val==='string' && !isURI(val)) errors.push(`"${key}" must be valid uri`);
      if (def.enum && !def.enum.includes(val)) errors.push(`"${key}" must be one of [${def.enum.join(', ')}]`);
    }else if (t==='array'){
      if (!Array.isArray(val)) { errors.push(`"${key}" must be array`); return; }
      const it=def.items||{};
      val.forEach((v,i)=>{
        if (it.type==='string'){
          if (typeof v!=='string') errors.push(`"${key}[${i}]" must be string`);
        }else if (it.type==='object'){
          if (typeof v!=='object' || v===null || Array.isArray(v)) { errors.push(`"${key}[${i}]" must be object`); return; }
          (it.required||[]).forEach(rk=>{ if(!(rk in v)) errors.push(`"${key}[${i}].${rk}" is required`); });
          const mp=it.properties||{};
          Object.keys(v).forEach(child=>{
            const d=mp[child]; const vv=v[child];
            if (!d) return;
            if (d.type==='string'){
              if (typeof vv!=='string') errors.push(`"${key}[${i}].${child}" must be string`);
              if (d.enum && !d.enum.includes(vv)) errors.push(`"${key}[${i}].${child}" invalid`);
              if (d.format==='uri' && !isURI(vv)) errors.push(`"${key}[${i}].${child}" must be uri`);
            }
          });
        }
      });
    }else if (t==='object'){
      if (typeof val!=='object' || val===null || Array.isArray(val)) errors.push(`"${key}" must be object`);
    }
  }
  Object.keys(props).forEach(k=>{ if (k in seal) check(k, seal[k], props[k]); });
  return {ok: errors.length===0, errors};
}

// ========== Parsing TXT → Seal ==========
function parseTxtToSeal(raw, autoIndex=1){
  const text = cleanText(raw);
  const lines = text.split('\n');

  let id = (text.match(/\bSEAL_[A-Z0-9\-_]+/i)||[])[0];
  if (!id) id = 'SEAL_AUTO_' + String(autoIndex).padStart(3,'0');

  const kv = {};
  lines.forEach(ln=>{
    const m = ln.match(/^\s*([A-Za-z_]+)\s*:\s*(.+)$/);
    if (m) kv[m[1].toLowerCase()] = m[2].trim();
  });

  const title = kv.title || firstNonEmptyLine(text);
  const equation = kv.equation || (text.match(/(?:^|\n)\s*(?:EQ|Equation)\s*:\s*(.+)/i)?.[1] || '');
  const tone = (kv.tone || '').toLowerCase() || (/\b(bright|dark|neutral|solar|lunar|void)\b/i.exec(text)?.[1]||'neutral');
  const glyph = kv.glyph || (text.match(/(?:^|\s)GLYPH[_\s:]*([A-Z0-9\-\_]+)/i)?.[1] || '');
  const tags = Array.from(new Set((text.match(/#([A-Za-z0-9_\-]+)/g)||[]).map(h=>h.slice(1))));
  const linked = Array.from(new Set(text.match(/\bSEAL_[A-Z0-9\-_]+/gi)||[]));
  const quote = kv.quote || (text.match(/[“"](.*?)[”"]/s)||[])[1] || '';
  const notes = kv.notes || text;
  const media_links = [];
  const urls = Array.from(new Set(text.match(/\bhttps?:\/\/\S+/gi)||[]));
  urls.forEach(u=>{
    const l=u.toLowerCase(); let type='other';
    if (/\.(png|jpg|jpeg|webp|svg)$/.test(l)) type='image';
    else if (/\.(gif)$/.test(l)) type='gif';
    else if (/\.(mp4|webm|mov)$/.test(l)) type='video';
    else if (/\.(mp3|wav|ogg|flac|m4a)$/.test(l)) type='audio';
    media_links.push({type, url:u});
  });

  const date = nowISO();
  return { id, title, equation, tone, glyph, tags, linked_seals: linked, quote, notes, media_links, date };
}

// ========== Editor ==========
function getEditorData(){
  const tags = refs.f_tags.value.split(',').map(s=>s.trim()).filter(Boolean);
  const linked = refs.f_linked.value.split(',').map(s=>s.trim()).filter(Boolean);
  const media = [];
  $$('#mediaList > div').forEach(row=>{
    const type = row.children[0].value.trim();
    const url = row.children[1].value.trim();
    if (type && url) media.push({type, url});
  });
  return {
    id: refs.f_id.value.trim(),
    title: refs.f_title.value.trim(),
    equation: refs.f_equation.value.trim(),
    tone: refs.f_tone.value.trim(),
    glyph: refs.f_glyph.value.trim(),
    tags,
    linked_seals: linked,
    quote: refs.f_quote.value,
    notes: refs.f_notes.value,
    media_links: media,
    date: refs.f_date.value.trim() || nowISO()
  };
}
function setEditorData(e){
  refs.f_id.value = e.id || '';
  refs.f_title.value = e.title || '';
  refs.f_equation.value = e.equation || '';
  refs.f_tone.value = e.tone || '';
  refs.f_glyph.value = e.glyph || '';
  refs.f_tags.value = (e.tags||[]).join(', ');
  refs.f_linked.value = (e.linked_seals||[]).join(', ');
  refs.f_quote.value = e.quote || '';
  refs.f_notes.value = e.notes || '';
  refs.f_date.value = e.date || nowISO();
  renderMedia(e.media_links||[]);
  refreshPreview();
  updateLinkedSuggest();
}
function renderMedia(list){
  refs.mediaList.innerHTML = '';
  (list||[]).forEach((m,i)=>{
    const row=document.createElement('div');
    row.className='toolbar'; row.style.margin='6px 0';
    row.innerHTML=`
      <select>
        <option ${m.type==='image'?'selected':''}>image</option>
        <option ${m.type==='gif'?'selected':''}>gif</option>
        <option ${m.type==='video'?'selected':''}>video</option>
        <option ${m.type==='audio'?'selected':''}>audio</option>
        <option ${m.type==='other'?'selected':''}>other</option>
      </select>
      <input type="url" value="${escapeAttr(m.url||'')}" style="flex:1" />
      <button data-act="up" class="btn">↑</button>
      <button data-act="down" class="btn">↓</button>
      <button data-act="rm" class="btn btn-danger">Remove</button>
    `;
    const [sel,url]=[row.children[0], row.children[1]];
    if (currentIndex>=0){
      sel.addEventListener('change',()=>{ parsedSeals[currentIndex].media_links[i].type = sel.value; refreshPreview(); });
      url.addEventListener('input',()=>{ parsedSeals[currentIndex].media_links[i].url = url.value; refreshPreview(); });
      row.querySelector('[data-act="rm"]').addEventListener('click', ()=>{ parsedSeals[currentIndex].media_links.splice(i,1); renderMedia(parsedSeals[currentIndex].media_links); refreshPreview(); });
      row.querySelector('[data-act="up"]').addEventListener('click', ()=>{ const j=i-1; if(j<0)return; const a=parsedSeals[currentIndex].media_links; [a[i],a[j]]=[a[j],a[i]]; renderMedia(a); refreshPreview(); });
      row.querySelector('[data-act="down"]').addEventListener('click', ()=>{ const j=i+1; const a=parsedSeals[currentIndex].media_links; if(j>=a.length)return; [a[i],a[j]]=[a[j],a[i]]; renderMedia(a); refreshPreview(); });
    }
    refs.mediaList.appendChild(row);
  });
}

// ========== PHASE 2: Markdown Renderer (offline) ==========
function mdRender(src){
  let s = src || '';
  s = s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  // fenced code first
  s = s.replace(/```([\s\S]*?)```/g, (_,code)=> `<pre><code>${code.replace(/&/g,'&amp;')}</code></pre>`);
  // headings
  s = s.replace(/^###### (.*)$/gm,'<h6>$1</h6>')
       .replace(/^##### (.*)$/gm,'<h5>$1</h5>')
       .replace(/^#### (.*)$/gm,'<h4>$1</h4>')
       .replace(/^### (.*)$/gm,'<h3>$1</h3>')
       .replace(/^## (.*)$/gm,'<h2>$1</h2>')
       .replace(/^# (.*)$/gm,'<h1>$1</h1>');
  // inline
  s = s.replace(/`([^`]+)`/g,'<code>$1</code>')
       .replace(/\*\*([^*]+)\*\*/g,'<strong>$1</strong>')
       .replace(/_([^_]+)_/g,'<em>$1</em>');
  // images then links
  s = s.replace(/!\[([^\]]*)\]\(([^)]+)\)/g,'<img alt="$1" src="$2" style="max-width:100%;">');
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g,'<a href="$2" target="_blank" rel="noopener">$1</a>');
  // lists
  s = s.replace(/^(?:-|\*) (.*)$/gm,'<li>$1</li>');
  s = s.replace(/(<li>[\s\S]*?<\/li>)/g,'<ul>$1</ul>');
  // paragraphs
  s = s.replace(/^(?!<h\d|<ul|<pre|<p|<img|<blockquote)(.+)$/gm,'<p>$1</p>');
  return s;
}
console.log('PHASE 2 ready');

// ========== PHASE 2: SHA-256 ==========
async function sha256Hex(str){
  const buf = new TextEncoder().encode(str);
  const hash = await crypto.subtle.digest('SHA-256', buf);
  return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
}

// ========== Preview & Hash ==========
let hashTimer=0;
function refreshPreview(){
  if (currentIndex>=0) parsedSeals[currentIndex] = getEditorData();
  const obj = currentIndex>=0 ? parsedSeals[currentIndex] : getEditorData();
  const v = validateSeal(obj, SCHEMA);
  refs.jsonPreview.textContent = JSON.stringify(obj, null, 2) + (v.ok?'':`\n\n// Issues:\n// - ${v.errors.join('\n// - ')}`);
  refs.validBadge.textContent = v.ok ? 'valid' : 'invalid';
  refs.validBadge.className = v.ok ? 'status-ok' : 'status-bad';
  // hash (debounced)
  clearTimeout(hashTimer);
  hashTimer = setTimeout(async ()=>{
    const h = await sha256Hex(JSON.stringify(obj));
    refs.hashField.value = h;
  }, 80);
  // markdown notes
  refs.notesPreview.innerHTML = mdRender(obj.notes||'');
  // update loop detector to include parsed too
  detectCycles();
}

// ========== Parsed & Archive Rendering ==========
function renderParsed(){
  refs.parsedCount.textContent = String(parsedSeals.length);
  refs.parsedCount2.textContent = String(parsedSeals.length);
  refs.btnClearParsed.disabled = parsedSeals.length===0;

  refs.parsedBody.innerHTML='';
  parsedSeals.forEach((e,idx)=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`
      <td>${idx+1}</td>
      <td>${escapeHtml(e.id||'')}</td>
      <td>${escapeHtml(e.title||'')}</td>
      <td>${escapeHtml(e.tone||'')}</td>
      <td>${(e.tags||[]).length}</td>
      <td>${(e.linked_seals||[]).length}</td>
      <td>${escapeHtml(e.date||'')}</td>
      <td class="right">
        <button data-act="edit" class="btn">Edit</button>
        <button data-act="dup" class="btn">Duplicate</button>
        <button data-act="dl" class="btn">Download</button>
        <button data-act="rm" class="btn btn-danger">Delete</button>
      </td>
    `;
    tr.querySelector('[data-act="edit"]').addEventListener('click',()=> loadEditor(idx));
    tr.querySelector('[data-act="dup"]').addEventListener('click',()=>{
      const copy = structuredCloneSafe(e);
      copy.id = (e.id||'SEAL') + '_COPY';
      parsedSeals.splice(idx+1,0,copy);
      renderParsed(); detectCycles();
    });
    tr.querySelector('[data-act="dl"]').addEventListener('click',()=> downloadJSON(e, safeName(e.id||e.title)+'.json'));
    tr.querySelector('[data-act="rm"]').addEventListener('click',()=>{
      parsedSeals.splice(idx,1);
      if (currentIndex===idx){ clearEditor(); }
      else if (currentIndex>idx) currentIndex--;
      renderParsed(); detectCycles();
    });
    tr.addEventListener('mousemove', (ev)=> showMiniPreview(ev, e));
    tr.addEventListener('mouseleave', hideMiniPreview);
    refs.parsedBody.appendChild(tr);
  });
}

function getSelectedFilterValues(){
  return {
    tags: getSelectedValues(refs.tagFilter),
    tones: getSelectedValues(refs.toneFilter)
  };
}

function sortArchive(list){
  const arr = list.slice();
  arr.sort((a,b)=>{
    let va, vb;
    if (sortKey==='id'){ va = a.id||''; vb=b.id||''; return va.localeCompare(vb)*sortDir; }
    if (sortKey==='title'){ va = a.title||''; vb=b.title||''; return va.localeCompare(vb)*sortDir; }
    if (sortKey==='tone'){ va = a.tone||''; vb=b.tone||''; return va.localeCompare(vb)*sortDir; }
    if (sortKey==='tags'){ va=(a.tags||[]).length; vb=(b.tags||[]).length; return (va-vb)*sortDir; }
    if (sortKey==='linked'){ va=(a.linked_seals||[]).length; vb=(b.linked_seals||[]).length; return (va-vb)*sortDir; }
    if (sortKey==='date'){ va=Date.parse(a.date||0)||0; vb=Date.parse(b.date||0)||0; return (va-vb)*sortDir; }
    return 0;
  });
  return arr;
}

function renderArchive(){
  refs.archiveCount.textContent = String(archive.length);
  refs.btnExportArchive.disabled = archive.length===0;
  refs.btnClearArchive.disabled = archive.length===0;

  const {tags, tones} = getSelectedFilterValues();
  const pass = s => {
    const passTag = !tags.length || (s.tags||[]).some(t=> tags.includes(t));
    const passTone = !tones.length || tones.includes(s.tone||'');
    return passTag && passTone;
  };
  const filtered = archive.filter(pass);
  const sorted = sortArchive(filtered);

  const headCells = $$('thead th[data-sort]');
  headCells.forEach(th=>{
    th.classList.remove('sorting'); th.querySelector('.dir').textContent='';
    if (th.dataset.sort===sortKey){ th.classList.add('sorting'); th.querySelector('.dir').textContent = sortDir>0?'▲':'▼'; }
  });

  refs.archiveBody.innerHTML='';
  sorted.forEach((e)=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`
      <td>${escapeHtml(e.id||'')}</td>
      <td>${escapeHtml(e.title||'')}</td>
      <td>${escapeHtml(e.tone||'')}</td>
      <td>${(e.tags||[]).length}</td>
      <td>${(e.linked_seals||[]).length}</td>
      <td>${escapeHtml(e.date||'')}</td>
      <td class="right">
        <button data-act="dl" class="btn">Download</button>
        <button data-act="rm" class="btn btn-danger">Remove</button>
      </td>
    `;
    tr.querySelector('[data-act="dl"]').addEventListener('click',()=> downloadJSON(e, safeName(e.id||e.title)+'.json'));
    tr.querySelector('[data-act="rm"]').addEventListener('click',()=>{
      const i = archive.indexOf(e);
      if (i>-1){ archive.splice(i,1); renderArchive(); updateFiltersFromArchive(); detectCycles(); saveArchiveLS(); }
    });
    tr.addEventListener('mousemove', (ev)=> showMiniPreview(ev, e));
    tr.addEventListener('mouseleave', hideMiniPreview);
    refs.archiveBody.appendChild(tr);
  });

  saveArchiveLS();
}

// ========== Mini Preview ==========
const mini = document.getElementById('miniPreview');
function showMiniPreview(ev, s){
  mini.innerHTML = `
    <div class="title">${escapeHtml(s.id||'')} — ${escapeHtml(s.title||'')}</div>
    <div class="line"><strong>Tone:</strong> ${escapeHtml(s.tone||'')}</div>
    <div class="line"><strong>Equation:</strong> ${escapeHtml(s.equation||'')}</div>
    <div class="line"><strong>Glyph:</strong> ${escapeHtml(s.glyph||'')}</div>
  `;
  mini.style.left = (ev.pageX + 14) + 'px';
  mini.style.top = (ev.pageY + 14) + 'px';
  mini.style.display='block';
}
function hideMiniPreview(){ mini.style.display='none'; }

// ========== PHASE 2: Autocomplete (from archive IDs) ==========
const suggestBox = document.getElementById('suggestBox');
function updateLinkedSuggest(){
  const source = Array.from(new Set(archive.map(s=>s.id).filter(Boolean)));
  const input = refs.f_linked;
  input.oninput = ()=>{
    const val = input.value;
    const parts = val.split(',');
    const lastRaw = parts[parts.length-1].trim().toUpperCase();
    if (!lastRaw){ suggestBox.style.display='none'; return; }
    const matches = source.filter(id=> id && id.toUpperCase().includes(lastRaw)).slice(0,20);
    if (!matches.length){ suggestBox.style.display='none'; return; }
    const rect = input.getBoundingClientRect();
    suggestBox.style.left = rect.left + 'px';
    suggestBox.style.top = (rect.bottom + window.scrollY + 4) + 'px';
    suggestBox.style.minWidth = rect.width + 'px';
    suggestBox.innerHTML = matches.map(m=>`<button type="button" data-id="${escapeAttr(m)}">${escapeHtml(m)}</button>`).join('');
    suggestBox.style.display='block';
    $$('button', suggestBox).forEach(btn=>{
      btn.addEventListener('click', ()=>{
        parts[parts.length-1] = ' ' + btn.dataset.id;
        input.value = parts.join(',').replace(/^,/, '');
        suggestBox.style.display='none';
        refreshPreview();
      });
    });
  };
  input.addEventListener('blur', ()=> setTimeout(()=> suggestBox.style.display='none', 150));
}

// ========== Hints ==========
const tooltip = document.getElementById('tooltip');
function bindHints(){
  const hintbar = refs.hintbar;
  $$('label[data-hint]').forEach(label=>{
    const hint = label.getAttribute('data-hint');
    const input = label.nextElementSibling;
    if (!input) return;
    function showTip(ev){
      hintbar.textContent = hint;
      tooltip.textContent = hint;
      tooltip.style.display='block';
      tooltip.style.left = (ev.pageX + 12) + 'px';
      tooltip.style.top = (ev.pageY + 12) + 'px';
    }
    function moveTip(ev){
      tooltip.style.left = (ev.pageX + 12) + 'px';
      tooltip.style.top = (ev.pageY + 12) + 'px';
    }
    function hideTip(){ tooltip.style.display='none'; }
    input.addEventListener('mouseenter', showTip);
    input.addEventListener('mousemove', moveTip);
    input.addEventListener('mouseleave', hideTip);
    input.addEventListener('focus', (ev)=> showTip(ev));
    input.addEventListener('blur', hideTip);
  });
}

// ========== Sorting ==========
$$('thead th[data-sort]').forEach(th=>{
  th.addEventListener('click', ()=>{
    const key = th.dataset.sort;
    if (sortKey===key) sortDir*=-1; else { sortKey=key; sortDir=1; }
    renderArchive();
  });
});

// ========== Import / Export ==========
function downloadJSON(obj, filename){
  const blob = new Blob([JSON.stringify(obj,null,2)], {type:'application/json'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob); a.download=filename;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href),0);
}
refs.btnExportArchive.addEventListener('click', ()=>{
  const shape = refs.exportShape.value;
  // ensure seal_hash on export
  const payloadArr = archive.map(s=>{
    const copy = structuredCloneSafe(s);
    if (!copy.seal_hash) copy.seal_hash = copy.seal_hash; // no-op if present
    return copy;
  });
  const payload = shape==='array' ? payloadArr : { seals: payloadArr };
  downloadJSON(payload, 'lygo-data-two.json');
});

// PHASE 3: Export PDF (scroll) via print-to-PDF
refs.btnExportPDF.addEventListener('click', ()=>{
  const html = `
<!doctype html><html><head><meta charset="utf-8"><title>LYRA Seals — Scroll</title>
<style>body{font:14px/1.5 ${CSS.escape(getComputedStyle(document.body).fontFamily)};padding:24px;color:#111;}
h1{margin-bottom:0.5rem} h2{margin:18px 0 6px;}
.seal{border-bottom:1px solid #ccc; padding:10px 0;}
pre{white-space:pre-wrap;border:1px solid #eee;padding:8px;border-radius:6px;background:#fafafa;}
blockquote{margin:8px 0;padding-left:12px;border-left:3px solid #ddd;color:#555;}
small{color:#666}
</style></head><body>
<h1>LYRA Seals</h1>
${archive.map(s=>`
<div class="seal">
  <h2>${escapeHtml(s.id||'')} — ${escapeHtml(s.title||'')}</h2>
  <small>Tone: ${escapeHtml(s.tone||'')} • Date: ${escapeHtml(s.date||'')}</small>
  <div><strong>Equation:</strong> ${escapeHtml(s.equation||'')}</div>
  <div><strong>Glyph:</strong> ${escapeHtml(s.glyph||'')}</div>
  <div><strong>Tags:</strong> ${(s.tags||[]).map(t=>escapeHtml(t)).join(', ')}</div>
  <div><strong>Linked:</strong> ${(s.linked_seals||[]).map(t=>escapeHtml(t)).join(', ')}</div>
  ${s.quote?`<blockquote>${escapeHtml(s.quote)}</blockquote>`:''}
  <div>${mdRender(s.notes||'')}</div>
</div>`).join('')}
<script>window.print()</script>
</body></html>`;
  const w = window.open('', '_blank');
  w.document.write(html); w.document.close();
});
console.log('PHASE 3 ready');

// ========== GH Upload ==========
async function ghGet(path, token){
  const r = await fetch(path, { headers: token? {Authorization:'token '+token} : {} });
  const t = await r.text();
  return { status:r.status, text:t, json:()=>{ try{return JSON.parse(t);}catch{return {};}} };
}
refs.btnCheckGH.addEventListener('click', async ()=>{
  const repo = refs.ghRepo.value.trim();
  const branch = refs.ghBranch.value.trim();
  const path = refs.ghPath.value.trim();
  const token = refs.ghToken.value.trim();
  if (!repo||!branch||!path){ refs.ghLog.textContent='Missing repo/branch/path'; return; }
  const url = `https://api.github.com/repos/${repo}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
  try{
    const r = await ghGet(url, token);
    refs.ghLog.textContent = `GET ${url}\nStatus: ${r.status}\n\n${r.text}`;
  }catch(e){ refs.ghLog.textContent = 'Error: ' + (e?.message||String(e)); }
});

refs.btnPushGH.addEventListener('click', async ()=>{
  const repo = refs.ghRepo.value.trim();
  const branch = refs.ghBranch.value.trim();
  const path = refs.ghPath.value.trim();
  const token = refs.ghToken.value.trim();
  const message = refs.ghMessage.value.trim() || 'Update from SEALMAKER';
  if (!repo||!branch||!path||!token){ refs.ghLog.textContent='Missing repo/branch/path/token'; return; }

  const url = `https://api.github.com/repos/${repo}/contents/${encodeURIComponent(path)}`;
  let sha=null;
  try{
    const r = await ghGet(url+`?ref=${encodeURIComponent(branch)}`, token);
    if (r.status===200){ sha = r.json().sha; }
  }catch{}

  // ensure seal_hash per item before upload
  const arr = await Promise.all(archive.map(async s=>{
    const copy = structuredCloneSafe(s);
    const h = await sha256Hex(JSON.stringify(copy));
    copy.seal_hash = h;
    return copy;
  }));
  const shape = refs.exportShape.value;
  const payload = shape==='array' ? arr : { seals: arr };
  const content = base64EncodeUtf8(JSON.stringify(payload, null, 2));
  const body = { message, content, branch };
  if (sha) body.sha = sha;

  try{
    const res = await fetch(url, {
      method:'PUT',
      headers:{ 'Authorization':'token '+token, 'Content-Type':'application/json' },
      body: JSON.stringify(body)
    });
    const txt = await res.text();
    refs.ghLog.textContent = `PUT ${url}\nStatus: ${res.status}\n\n${txt}`;
  }catch(e){
    refs.ghLog.textContent = 'Error: ' + (e?.message||String(e));
  }
});

// ========== PHASE 3: Circular Link Detector (archive + parsed) ==========
function detectCycles(){
  const map = new Map();
  // include archive and parsed in-progress
  [...archive, ...parsedSeals].forEach(s=>{
    if (!s?.id) return;
    map.set(s.id, (s.linked_seals||[]).filter(Boolean));
  });
  const visited=new Set(), stack=new Set();
  const loops=[];
  function dfs(node, path){
    if (!map.has(node)) return;
    visited.add(node); stack.add(node);
    for (const nb of map.get(node)){
      const n = nb;
      if (!map.has(n)) continue;
      if (!visited.has(n)) dfs(n, path.concat([n]));
      else if (stack.has(n)){
        // loop path: ... -> n (already in stack)
        const startIndex = path.indexOf(n);
        const loopPath = startIndex>=0 ? path.slice(startIndex).concat([n]) : path.concat([n]);
        loops.push(loopPath);
      }
    }
    stack.delete(node);
  }
  for (const k of map.keys()) if (!visited.has(k)) dfs(k,[k]);

  if (loops.length){
    const one = loops[0].join(' ↔ ');
    refs.cycleWarn.textContent = `⚠️ Loop Detected: ${one}${loops.length>1?` (+${loops.length-1} more)`:''}`;
  } else {
    refs.cycleWarn.textContent = 'Links: clean';
  }
}

// ========== Import / Paste / Drop ==========
refs.btnImportJson.addEventListener('click', ()=> refs.jsonFile.click());
refs.jsonFile.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if (!f) return;
  try{
    const text = await f.text();
    const data = JSON.parse(text);
    const arr = Array.isArray(data) ? data : (Array.isArray(data.seals) ? data.seals : []);
    if (!Array.isArray(arr)) throw new Error('Expected array or { seals: [] }');
    let added=0;
    for (const s of arr){
      const v = validateSeal(s, SCHEMA);
      if (v.ok){
        // ensure hash on import
        s.seal_hash = await sha256Hex(JSON.stringify(s));
        archive.push(s); added++;
      }
    }
    renderArchive(); updateFiltersFromArchive(); detectCycles();
    alert(`Imported ${added} seals into archive.`);
  }catch(err){
    alert('Import failed: '+(err?.message||String(err)));
  }finally{ e.target.value=''; }
});

refs.btnImportTxt.addEventListener('click', ()=> refs.txtFile.click());
refs.txtFile.addEventListener('change', e=> handleTxtFiles(e.target.files));
async function handleTxtFiles(files){
  const list = Array.from(files||[]).filter(f=>/\.txt$/i.test(f.name));
  if (!list.length) return;
  let i = parsedSeals.length + 1;
  for (const f of list){
    const t = await f.text();
    parsedSeals.push(parseTxtToSeal(t, i++));
  }
  renderParsed(); detectCycles();
  if (currentIndex===-1 && parsedSeals.length) loadEditor(0);
}

refs.dropzone.addEventListener('click', ()=> refs.jsonFile.click());
refs.dropzone.addEventListener('dragover', e=>{ e.preventDefault(); refs.dropzone.classList.add('dragover'); });
refs.dropzone.addEventListener('dragleave', ()=> refs.dropzone.classList.remove('dragover'));
refs.dropzone.addEventListener('drop', async (e)=>{
  e.preventDefault(); refs.dropzone.classList.remove('dragover');
  const items = Array.from(e.dataTransfer.files||[]);
  const jsons = items.filter(f=>/\.json$/i.test(f.name));
  const txts  = items.filter(f=>/\.txt$/i.test(f.name));
  if (jsons.length){
    const text = await jsons[0].text();
    try{
      const data = JSON.parse(text);
      const arr = Array.isArray(data) ? data : (Array.isArray(data.seals)? data.seals: []);
      arr.forEach(s=> parsedSeals.push(s));
      renderParsed(); detectCycles();
      if (currentIndex===-1) loadEditor(0);
    }catch(err){ alert('Dropped JSON failed to parse'); }
  }
  if (txts.length) handleTxtFiles(txts);
});

// Paste parsing
refs.btnParsePaste.addEventListener('click', ()=>{
  const raw = refs.pasteArea.value||''; if (!raw.trim()) return;
  const t = cleanText(raw);
  let blocks=[t];
  if (refs.splitStrategy.value==='blank') blocks = t.split(/\n{2,}\s*\n*/).map(s=>s.trim()).filter(Boolean);
  else if (refs.splitStrategy.value==='hr') blocks = t.split(/\n-{3,}\n/).map(s=>s.trim()).filter(Boolean);
  let i = parsedSeals.length + 1;
  blocks.forEach(b=> parsedSeals.push(parseTxtToSeal(b, i++)));
  renderParsed(); detectCycles();
  if (currentIndex===-1) loadEditor(0);
});
refs.btnClearPaste.addEventListener('click', ()=> refs.pasteArea.value='');

// Append/clear parsed
refs.btnAppendAll.addEventListener('click', async ()=>{
  let added=0;
  for (const s of parsedSeals){
    const v=validateSeal(s,SCHEMA);
    if (v.ok){
      s.seal_hash = await sha256Hex(JSON.stringify(s));
      archive.push(structuredCloneSafe(s)); added++;
    }
  }
  renderArchive(); updateFiltersFromArchive(); detectCycles();
  alert(`Appended ${added} valid seals to archive.`);
});
refs.btnClearParsed.addEventListener('click', ()=>{
  if (!parsedSeals.length) return;
  if (!confirm('Clear all parsed seals?')) return;
  parsedSeals=[]; renderParsed(); clearEditor(); detectCycles();
});

// Editor actions
refs.btnAppendOne.addEventListener('click', async ()=>{
  if (currentIndex<0) return;
  const seal = parsedSeals[currentIndex];
  const v=validateSeal(seal,SCHEMA);
  if (!v.ok){ alert('Fix before append:\n- '+v.errors.join('\n- ')); return; }
  seal.seal_hash = await sha256Hex(JSON.stringify(seal));
  archive.push(structuredCloneSafe(seal));
  renderArchive(); updateFiltersFromArchive(); detectCycles();
});
refs.btnDownloadOne.addEventListener('click', ()=>{
  if (currentIndex<0) return;
  const seal = parsedSeals[currentIndex];
  const v=validateSeal(seal,SCHEMA);
  if (!v.ok){ alert('Fix before download:\n- '+v.errors.join('\n- ')); return; }
  downloadJSON(seal, safeName(seal.id||seal.title)+'.json');
});
['input','change'].forEach(evt=>{
  [refs.f_id, refs.f_title, refs.f_equation, refs.f_tone, refs.f_glyph, refs.f_tags, refs.f_linked, refs.f_quote, refs.f_notes, refs.f_date]
    .forEach(el=> el.addEventListener(evt, refreshPreview));
});
refs.btnAddMedia.addEventListener('click', ()=>{
  const type = refs.mediaType.value;
  const url = refs.mediaUrl.value.trim();
  if (!type || !url) return;
  if (currentIndex<0){
    const tmp = getEditorData(); tmp.media_links.push({type,url}); setEditorData(tmp);
  }else{
    parsedSeals[currentIndex].media_links.push({type,url});
    refs.mediaUrl.value=''; renderMedia(parsedSeals[currentIndex].media_links); refreshPreview();
  }
});
refs.btnNow.addEventListener('click', ()=>{ refs.f_date.value = nowISO(); refreshPreview(); });

// Sorting headers
$$('thead th[data-sort]').forEach(th=>{
  th.addEventListener('click', ()=>{
    const key = th.dataset.sort;
    if (sortKey===key) sortDir*=-1; else { sortKey=key; sortDir=1; }
    renderArchive();
  });
});

// Tabs
refs.tabs.forEach(t=>{
  t.addEventListener('click', ()=>{
    refs.tabs.forEach(x=>x.classList.remove('active')); t.classList.add('active');
    const name=t.dataset.tab;
    $('#tab-builder').style.display = name==='builder'?'block':'none';
    $('#tab-extras').style.display = name==='extras'?'block':'none';
  });
});

// Schema controls
refs.schemaText.value = JSON.stringify(DEFAULT_SEAL_SCHEMA, null, 2);
refs.btnApplySchema.addEventListener('click', ()=>{
  try{
    const s = JSON.parse(refs.schemaText.value);
    if (!s || typeof s!=='object') throw new Error('Schema must be an object');
    SCHEMA = s; refs.schemaStatus.textContent = 'Active (custom)';
    refreshPreview();
  }catch(e){ alert('Schema parse error: '+(e?.message||String(e))); }
});
refs.btnResetSchema.addEventListener('click', ()=>{
  SCHEMA = JSON.parse(JSON.stringify(DEFAULT_SEAL_SCHEMA));
  refs.schemaText.value = JSON.stringify(DEFAULT_SEAL_SCHEMA, null, 2);
  refs.schemaStatus.textContent = 'Active (default)';
  refreshPreview();
});

// Export Archive (shape already handled above)
refs.btnClearArchive.addEventListener('click', ()=>{
  if (!archive.length) return;
  if (!confirm('Clear entire archive?')) return;
  archive = []; renderArchive(); updateFiltersFromArchive(); detectCycles();
});

// Init
(function init(){
  bindHints();
  clearEditor();
  renderParsed();
  renderArchive();
  updateFiltersFromArchive();
  showRecoveryIfAvailable();
  console.log('%cSEALMAKER ready', 'color:#00ff88');
})();
</script>
</body>
</html>
